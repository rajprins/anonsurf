#!/usr/bin/env python3

import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Gdk', '4.0')
gi.require_version('Adw', '1')
from gi.repository import Gtk, Gdk, GLib, GObject, Adw
import warnings
import subprocess
import os
import sys
import threading
import tempfile
import xml.etree.ElementTree as ET
from typing import Optional
import time
import signal


class AnonSurfGUI:
    def __init__(self):
        # Use Gtk.ApplicationWindow to allow setting a custom titlebar
        self.window = Gtk.ApplicationWindow()
        self.window.set_title("AnonSurf")
        self.window.set_name("anonsurf")  # Set internal name
        self.window.connect("close-request", self.on_window_close)
        
        # Performance optimizations
        self._status_cache = {}
        self._last_status_check = 0
        self._status_cache_timeout = 2.0  # Cache for 2 seconds
        self._subprocess_timeout = 10.0  # 10 second timeout for subprocess calls
        
        # Add CSS styling for regular font weight
        css_provider = Gtk.CssProvider()
        # Suppress upstream deprecation for CssProvider.load_from_data
        # (the gi override emits a DeprecationWarning). We keep using
        # load_from_data for compatibility but avoid noisy warnings.
        css = """
        .regular-weight {
            font-weight: normal;
        }
        .header-title {
            font-size: 14px;
            font-weight: 800;
        }
        .header-title-box {
            margin: 0;
            padding: 0;
        }
        .header-title-box label {
            margin: 0;
            padding: 0;
        }
        .tor-active {
            background-color: #e8f5e8;
            border: 2px solid #4caf50;
        }
        /* Ensure the main panel background reflects Tor status even when
           theme classes (e.g. light-mode) are present. Target both the
           window-level class as a parent and the panel itself. */
        .tor-active .main-panel,
        .main-panel.tor-active {
            background-color: #e8f5e8;
        }
        .tor-active headerbar {
            background-color: #4caf50;
            color: white;
        }
        .tor-inactive {
            background-color: #ffebee;
            border: 2px solid #f44336;
        }
        .tor-inactive .main-panel,
        .main-panel.tor-inactive {
            background-color: #ffebee;
        }
        .tor-inactive headerbar {
            background-color: #f44336;
            color: white;
        }
        /* Main panel background for light and dark modes. The clamp is
           transparent by default so the window-level background can show
           through; explicit light/dark rules are applied via classes on
           the window to ensure consistent theming across Adw widgets. */
        .main-panel {
            background-color: transparent;
        }

        .light-mode .main-panel {
            background-color: #ffffff;
            color: #111111;
        }

        .main-panel.light-mode {
            background-color: #ffffff;
            color: #111111;
        }

        /* When a Tor status class is present, make it more specific
           than the generic light-mode rule so the status background
           wins in light themes. */
        .light-mode .main-panel.tor-active,
        .main-panel.light-mode.tor-active {
            background-color: #e8f5e8;
            color: #111111;
        }

        .light-mode .main-panel.tor-inactive,
        .main-panel.light-mode.tor-inactive {
            background-color: #ffebee;
            color: #111111;
        }

        .main-panel.dark-mode {
            background-color: #2b2b2b;
            color: #eeeeee;
        }

        /* Remove any panel border/shadow in dark mode so the window
           retains the visual border while the inner panel appears
           seamless with the background. */
        .dark-mode .main-panel,
        .main-panel.dark-mode,
        .dark-mode .main-panel.tor-active,
        .main-panel.dark-mode.tor-active,
        .dark-mode .main-panel.tor-inactive,
        .main-panel.dark-mode.tor-inactive {
            border: none;
            box-shadow: none;
        }

        .dark-mode {
            background-color: #2b2b2b;
            color: #eeeeee;
        }

        .dark-mode headerbar {
            background-color: #1f1f1f;
            color: #ffffff;
        }
        """
        with warnings.catch_warnings():
            warnings.filterwarnings(
                "ignore",
                message=".*CssProvider.load_from_data.*",
                category=DeprecationWarning,
            )
            css_provider.load_from_data(css.encode())
        Gtk.StyleContext.add_provider_for_display(
            Gdk.Display.get_default(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        # Keep the window in sync with the system color scheme.
        try:
            style_manager = Adw.StyleManager.get_default()

            def _on_scheme_change(sm, prop=None):
                try:
                    is_dark = sm.get_color_scheme() == Adw.ColorScheme.DARK
                except Exception:
                    # Be conservative: assume light if we can't determine
                    is_dark = False

                # Also respect Gtk preference which some environments set
                try:
                    settings = Gtk.Settings.get_default()
                    if settings and settings.get_property('gtk-application-prefer-dark-theme'):
                        is_dark = True
                except Exception:
                    pass

                if is_dark:
                    self.window.add_css_class('dark-mode')
                    self.window.remove_css_class('light-mode')
                    try:
                        GLib.idle_add(self.window.set_title, "AnonSurf — Dark Mode")
                    except Exception:
                        pass
                else:
                    self.window.add_css_class('light-mode')
                    self.window.remove_css_class('dark-mode')
                    try:
                        GLib.idle_add(self.window.set_title, "AnonSurf")
                    except Exception:
                        pass

                # Mirror onto the main clamp if it exists so background
                # styling is applied directly to the panel widget.
                try:
                    clamp_exists = hasattr(self, 'main_clamp') and self.main_clamp is not None
                    gtk_pref = None
                    try:
                        s = Gtk.Settings.get_default()
                        if s:
                            gtk_pref = s.get_property('gtk-application-prefer-dark-theme')
                    except Exception:
                        pass
                    if clamp_exists:
                        if is_dark:
                            self.main_clamp.add_css_class('dark-mode')
                            self.main_clamp.remove_css_class('light-mode')
                        else:
                            self.main_clamp.add_css_class('light-mode')
                            self.main_clamp.remove_css_class('dark-mode')
                except Exception:
                    pass
                # Record for later if the UI hasn't created the clamp yet
                try:
                    self._pending_scheme_is_dark = is_dark
                except Exception:
                    pass

            # Apply initial scheme
            # Start with an explicit light-mode class; the handler will
            # switch to dark-mode if needed.
            self.window.add_css_class('light-mode')
            # Ensure we have a pending scheme flag in case the UI isn't
            # created yet (we'll apply to the clamp once it's available).
            self._pending_scheme_is_dark = None
            _on_scheme_change(style_manager)

            # React to changes at runtime
            style_manager.connect('notify::color-scheme', _on_scheme_change)

            # Also react to Gtk preference changes as some environments set
            # the dark preference via Gtk.Settings instead of Adw.StyleManager
            try:
                settings = Gtk.Settings.get_default()
                if settings:
                    def _on_gtk_pref_change(settings_obj, prop):
                        _on_scheme_change(style_manager)

                    settings.connect('notify::gtk-application-prefer-dark-theme', _on_gtk_pref_change)
            except Exception:
                pass
        except Exception:
            # If Adw.StyleManager isn't available or lacks methods on older
            # versions, silently continue with default styling.
            pass
        
        # Add a Gtk.HeaderBar with title and subtitle
        headerbar = Gtk.HeaderBar()
        headerbar.set_show_title_buttons(True)
        
        # Create title box with proper vertical centering
        title_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
        title_box.set_halign(Gtk.Align.CENTER)
        title_box.set_valign(Gtk.Align.CENTER)
        title_box.add_css_class("header-title-box")
        
        title_label = Gtk.Label(label="AnonSurf")
        title_label.add_css_class("header-title")
        title_label.set_halign(Gtk.Align.CENTER)
        title_label.set_valign(Gtk.Align.CENTER)
        
        subtitle_label = Gtk.Label(label="Anonymous Browsing Service")
        subtitle_label.add_css_class("dim-label")
        subtitle_label.set_halign(Gtk.Align.CENTER)
        subtitle_label.set_valign(Gtk.Align.CENTER)
        
        title_box.append(title_label)
        title_box.append(subtitle_label)
        headerbar.set_title_widget(title_box)
        
        # Add menu button with dropdown
        menu_button = Gtk.MenuButton()
        menu_button.set_icon_name("open-menu-symbolic")
        menu_button.set_tooltip_text("Menu")
        
        # Create popover menu (use Gtk.Popover to host custom content)
        popover = Gtk.Popover()
        menu_button.set_popover(popover)
        
        # Store popover reference for closing
        self.about_popover = popover
        
        # Create menu box
        menu_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        popover.set_child(menu_box)
        
        # Add About menu item
        about_item = Gtk.Button()
        about_item.set_label("About AnonSurf")
        about_item.connect("clicked", self.on_about_clicked)
        about_item.add_css_class("flat")
        about_item.add_css_class("regular-weight")
        about_item.set_halign(Gtk.Align.FILL)
        about_item.set_hexpand(True)
        # Get the child label and set it to left-align
        about_label = about_item.get_child()
        if about_label:
            about_label.set_halign(Gtk.Align.START)
        menu_box.append(about_item)
        
        # Add Quit menu item
        quit_item = Gtk.Button()
        quit_item.set_label("Quit")
        quit_item.connect("clicked", self.on_quit_clicked)
        quit_item.add_css_class("flat")
        quit_item.add_css_class("regular-weight")
        quit_item.set_halign(Gtk.Align.FILL)
        quit_item.set_hexpand(True)
        # Get the child label and set it to left-align
        quit_label = quit_item.get_child()
        if quit_label:
            quit_label.set_halign(Gtk.Align.START)
        menu_box.append(quit_item)
        
        headerbar.pack_end(menu_button)
        
        self.window.set_titlebar(headerbar)
        
        # Store password for sudo operations
        self.password: Optional[str] = None
        # Track if passwordless sudo is available
        self.can_sudo_nopass: bool = False
        
        # Check dependencies and initialize
        if not self.check_dependencies():
            sys.exit(1)
        
        if not self.init_sudo():
            sys.exit(1)
        
        self.setup_ui()
        self.update_status()
    
    # Handle window close request
    def on_window_close(self, window):
        Gtk.Application.get_default().quit()
        return False
    
    # Check if required dependencies are installed
    def check_dependencies(self) -> bool:
        # (normal execution) Check if AnonSurf CLI is installed
        # Check if AnonSurf CLI is installed
        if not os.path.exists('/etc/init.d/anonsurf'):
            self.show_error("Error: AnonSurf CLI is not installed.")
            return False
        
        # Check if curl is available
        try:
            subprocess.run(['curl', '--version'], capture_output=True, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            self.show_error("Error: Curl is not installed.")
            return False
        
        return True
    

    # Handle sudo password dialog response
    def on_sudo_response(self, dialog, response):
        if response == Gtk.ResponseType.OK:
            self.sudo_response = dialog.entry.get_text()
        else:
            self.sudo_response = ""
        
        return True


    # Handle start dialog response
    def on_start_response(self, dialog, response):
        dialog.destroy()
        if response == Gtk.ResponseType.YES:
            # Disable start button temporarily
            self.start_button.set_sensitive(False)
            self.run_anonsurf_command("start", "Starting anonymous browsing mode...")


    # Handle stop dialog response
    def on_stop_response(self, dialog, response):
        dialog.destroy()
        if response == Gtk.ResponseType.YES:
            # Disable stop button temporarily
            self.stop_button.set_sensitive(False)
            self.run_anonsurf_command("stop", "Stopping anonymous browsing mode...")
    
    # NOTE: `_run_subprocess_safe` has been removed. Call sites now use
    # `subprocess.run` directly and explicitly translate a `TimeoutExpired`
    # into a `CalledProcessError` to keep existing error handling paths.
    
    # Helper for creating consistent dialog windows
    def _create_dialog_window(self, title, default_size=(400, 200), modal=True):
        # Create a standardized dialog window with consistent styling
        dialog = Adw.ApplicationWindow()
        dialog.set_title(title)
        dialog.set_default_size(*default_size)
        dialog.set_transient_for(self.window)
        dialog.set_modal(modal)
        
        # Create consistent layout structure
        clamp = Adw.Clamp()
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=16)
        vbox.set_margin_start(20)
        vbox.set_margin_end(20)
        vbox.set_margin_top(20)
        vbox.set_margin_bottom(20)
        clamp.set_child(vbox)
        dialog.set_content(clamp)
        
        return dialog, vbox
    
    # Initialize sudo access
    def init_sudo(self) -> bool:
        if os.geteuid() != 0:
            # Try sudo without password first
            try:
                subprocess.run(['sudo', '-n', 'true'], check=True)
                self.can_sudo_nopass = True
                return True
            except FileNotFoundError:
                # `sudo` is not available on this system
                self.show_error("Error: 'sudo' is not installed. Please install sudo or run as root.")
                return False
            except subprocess.CalledProcessError:
                # Need password
                # Build a simple modal window to request sudo password
                win = Gtk.Window(transient_for=self.window)
                win.set_title("Permission Required")
                win.set_modal(True)
                win.set_default_size(300, 100)

                vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
                vbox.set_margin_top(12)
                vbox.set_margin_bottom(12)
                vbox.set_margin_start(12)
                vbox.set_margin_end(12)

                label = Gtk.Label(label="Enter your password:")
                entry = Gtk.PasswordEntry()
                # PasswordEntry does not implement `set_activates_default`; connect
                # the `activate` signal to trigger the OK action so pressing Enter submits.
                vbox.append(label)
                vbox.append(entry)

                btn_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
                btn_box.set_halign(Gtk.Align.END)

                cancel_btn = Gtk.Button.new_with_label("Cancel")
                ok_btn = Gtk.Button.new_with_label("OK")

                def on_ok(_):
                    self.sudo_response = entry.get_text()
                    win.destroy()

                def on_cancel(_):
                    self.sudo_response = ""
                    win.destroy()

                ok_btn.connect("clicked", on_ok)
                cancel_btn.connect("clicked", on_cancel)
                entry.connect("activate", lambda e: on_ok(e))

                btn_box.append(cancel_btn)
                btn_box.append(ok_btn)
                vbox.append(btn_box)

                win.set_child(vbox)
                win.present()

                # Wait for response using a simple loop (not ideal but works)
                self.sudo_response = None
                while self.sudo_response is None:
                    GLib.MainContext.default().iteration(True)

                password = self.sudo_response
                
                if password:
                    self.password = password
                    # Test the password
                    try:
                        # Provide the password as a string and include a newline
                        # so sudo receives a full line via stdin.
                        subprocess.run(['sudo', '-S', 'true'], input=password + '\n', capture_output=True, check=True, text=True)
                        return True
                    except FileNotFoundError:
                        self.show_error("Error: 'sudo' is not installed. Please install sudo or run as root.")
                        return False
                    except subprocess.CalledProcessError:
                        self.show_error("Error: Invalid password.")
                        return False
                else:
                    self.show_error("Error: No password entered. Aborting.")
                    return False
        else:
            # Running as root; no sudo needed
            self.can_sudo_nopass = True
        return True
    


    # Initialize the main UI
    def setup_ui(self):
        
        # Main container wrapped in Adw.Clamp for responsive margins
        clamp = Adw.Clamp()
        clamp.add_css_class('main-panel')
        # Keep a reference so theme handlers can mirror classes onto the clamp
        # after it is created.
        self.main_clamp = clamp

        # If theme handler ran earlier, apply the pending scheme to the clamp
        try:
            pending = getattr(self, '_pending_scheme_is_dark', None)
            if pending is True:
                clamp.add_css_class('dark-mode')
                clamp.remove_css_class('light-mode')
            elif pending is False:
                clamp.add_css_class('light-mode')
                clamp.remove_css_class('dark-mode')
        except Exception:
            pass
        
        #main_vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        main_vbox = Gtk.Box()
        clamp.set_child(main_vbox)
        
        # (Reverted) Remove large Quick Actions buttons; use Adwaita action rows below
        
        # Status section (Adwaita native)
        prefs_page = Adw.PreferencesPage()
        prefs_page.set_title("AnonSurf") # Set a title for the preferences page
        
        # Status group
        #status_group = Adw.PreferencesGroup(title="Status")
        status_group = Adw.PreferencesGroup()
        status_group.set_margin_start(10)
        status_group.set_margin_end(10)
        
        # Tor status row
        self.tor_row = Adw.ActionRow(title="Tor Service", subtitle="Unknown")
        status_group.add(self.tor_row)
        
        # IP address row with refresh suffix button
        self.ip_row = Adw.ActionRow(title="Public IP Address", subtitle="Unknown")
        status_group.add(self.ip_row)
        
        prefs_page.add(status_group)
        
        # Toggle button section (separate from other actions)
        toggle_group = Adw.PreferencesGroup()
        
        # Button container for start/stop
        start_stop_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        start_stop_box.set_margin_start(10)
        start_stop_box.set_margin_end(10)
        start_stop_box.set_margin_top(10)
        start_stop_box.set_margin_bottom(10)
        
        # Start button
        self.start_button = Gtk.Button()
        self.start_button.set_tooltip_text("Start Tor service")
        self.start_button.connect("clicked", self.on_start_clicked)
        self.start_button.set_hexpand(True)
        self.start_button.set_size_request(-1, 120)  # Fixed height of 120px
        
        # Start button icon and label
        start_vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=4)
        start_vbox.set_halign(Gtk.Align.CENTER)
        start_vbox.set_valign(Gtk.Align.CENTER)
        start_icon = Gtk.Image.new_from_icon_name("media-playback-start-symbolic")
        start_icon.set_pixel_size(32)
        start_label = Gtk.Label(label="Start")
        start_vbox.append(start_icon)
        start_vbox.append(start_label)
        self.start_button.set_child(start_vbox)
        start_stop_box.append(self.start_button)
        
        # Stop button
        self.stop_button = Gtk.Button()
        self.stop_button.set_tooltip_text("Stop Tor service")
        self.stop_button.connect("clicked", self.on_stop_clicked)
        self.stop_button.set_hexpand(True)
        self.stop_button.set_size_request(-1, 120)  # Fixed height of 120px
        
        # Stop button icon and label
        stop_vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=4)
        stop_vbox.set_halign(Gtk.Align.CENTER)
        stop_vbox.set_valign(Gtk.Align.CENTER)
        stop_icon = Gtk.Image.new_from_icon_name("media-playback-stop-symbolic")
        stop_icon.set_pixel_size(32)
        stop_label = Gtk.Label(label="Stop")
        stop_vbox.append(stop_icon)
        stop_vbox.append(stop_label)
        self.stop_button.set_child(stop_vbox)
        start_stop_box.append(self.stop_button)
        
        toggle_group.add(start_stop_box)
        prefs_page.add(toggle_group)
        
        # Actions section with traditional buttons
        actions_group = Adw.PreferencesGroup()
        
        # Button container for other actions
        button_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        button_box.set_margin_start(10)
        button_box.set_margin_end(10)
        button_box.set_margin_top(0)
        button_box.set_margin_bottom(0)
        
        # Change IP button
        self.change_btn = Gtk.Button(label="Change IP Address")
        self.change_btn.set_tooltip_text("Reload Tor circuits to obtain a new exit node")
        self.change_btn.connect("clicked", self.on_change_clicked)
        button_box.append(self.change_btn)
        
        # Show IP details button
        info_btn = Gtk.Button(label="IP Address Details")
        info_btn.set_tooltip_text("Show geolocation and ISP details")
        info_btn.connect("clicked", self.on_info_clicked)
        button_box.append(info_btn)
        
        actions_group.add(button_box)
        prefs_page.add(actions_group)
        
        main_vbox.append(prefs_page)
        
        # Install into window
        self.window.set_child(clamp)
        
        # Set application icon
        try:
            self.window.set_icon_name("anonsurf")
        except Exception as e:
            print(f"Warning: Could not set application icon: {e}")
        
        self.window.set_default_size(400, 470)
        self.window.set_resizable(False)
    

    # Update the status display
    def update_status(self, force_refresh=False):
        """Update status with caching to reduce system calls"""
        current_time = time.time()
        
        # Check cache first (unless force refresh)
        if not force_refresh and (current_time - self._last_status_check) < self._status_cache_timeout:
            if 'tor_status' in self._status_cache and 'ip_address' in self._status_cache:
                self.update_status_labels(
                    self._status_cache['tor_status'], 
                    self._status_cache['ip_address']
                )
                return
        
        def update():
            try:
                # Get Tor status with timeout
                try:
                    cmd = ['systemctl', 'is-active', 'tor']
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=5.0)
                    except subprocess.TimeoutExpired:
                        # Keep behavior consistent with previous helper
                        raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                    tor_status = result.stdout.strip()
                except subprocess.CalledProcessError:
                    tor_status = "inactive"

                # Get IP address with timeout (only if Tor is active to reduce unnecessary calls)
                if tor_status == "active":
                    try:
                        cmd = ['curl', '-s', '--max-time', '8', 'icanhazip.com']
                        try:
                            result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=10.0)
                        except subprocess.TimeoutExpired:
                            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                        ip_address = result.stdout.strip()
                        # Validate IP format
                        if not ip_address or len(ip_address.split('.')) != 4:
                            ip_address = "Unknown"
                    except subprocess.CalledProcessError:
                        ip_address = "Unknown"
                else:
                    # Don't waste time checking IP if Tor is inactive
                    ip_address = "Not connected"

                # Cache results
                self._status_cache = {
                    'tor_status': tor_status,
                    'ip_address': ip_address
                }
                self._last_status_check = time.time()

                # Update UI in main thread
                GLib.idle_add(self.update_status_labels, tor_status, ip_address)
                
            except Exception as e:
                # Fallback on any error
                GLib.idle_add(self.update_status_labels, "Error", f"Error: {str(e)}")

        # Run in background thread
        thread = threading.Thread(target=update)
        thread.daemon = True
        thread.start()
    

    # Update status labels (called from main thread)
    def update_status_labels(self, tor_status: str, ip_address: str):
        self.tor_row.set_subtitle(tor_status)
        self.ip_row.set_subtitle(ip_address)
        
        # Apply window color based on Tor status
        # Remove existing status classes first
        self.window.remove_css_class("tor-active")
        self.window.remove_css_class("tor-inactive")
        
        # Add appropriate status class (window-level)
        if tor_status == "active":
            self.window.add_css_class("tor-active")
        else:
            self.window.add_css_class("tor-inactive")

        # Also mirror the status class onto the main clamp/panel so
        # the background styling takes effect even if widget-level
        # rules are used by the theme.
        try:
            if hasattr(self, 'main_clamp') and self.main_clamp is not None:
                self.main_clamp.remove_css_class('tor-active')
                self.main_clamp.remove_css_class('tor-inactive')
                if tor_status == "active":
                    self.main_clamp.add_css_class('tor-active')
                else:
                    self.main_clamp.add_css_class('tor-inactive')
        except Exception:
            pass
        
        # Sync button states with Tor status
        if hasattr(self, 'start_button') and hasattr(self, 'stop_button'):
            is_active = tor_status == "active"
            self.start_button.set_sensitive(not is_active)  # Enable start when inactive
            self.stop_button.set_sensitive(is_active)       # Enable stop when active
            
            # Also sync the Change IP button - only enable when Tor is running
            if hasattr(self, 'change_btn'):
                self.change_btn.set_sensitive(is_active)

    # Handle start button click
    def on_start_clicked(self, button):
        # Show confirmation using a simple modal window (avoids deprecated
        # MessageDialog/response APIs)
        win = Gtk.Window(transient_for=self.window)
        win.set_title("Start AnonSurf")
        win.set_modal(True)
        win.set_default_size(400, 160)

        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        vbox.set_margin_top(12)
        vbox.set_margin_bottom(12)
        vbox.set_margin_start(12)
        vbox.set_margin_end(12)

        label = Gtk.Label(label="You are about to start the anonymous browsing service.\n\nActive browsers will be closed and cache files deleted.\n\nDo you wish to continue?")
        label.set_wrap(True)
        vbox.append(label)

        btn_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        btn_box.set_halign(Gtk.Align.END)

        no_btn = Gtk.Button.new_with_label("No")
        yes_btn = Gtk.Button.new_with_label("Yes")

        def on_yes(_):
            win.destroy()
            # Disable start button temporarily and execute command
            self.start_button.set_sensitive(False)
            self.run_anonsurf_command("start", "Starting anonymous browsing mode...")

        def on_no(_):
            win.destroy()

        yes_btn.connect("clicked", on_yes)
        no_btn.connect("clicked", on_no)

        btn_box.append(no_btn)
        btn_box.append(yes_btn)
        vbox.append(btn_box)

        win.set_child(vbox)
        win.present()

    # Handle stop button click
    def on_stop_clicked(self, button):
        # Show confirmation using a simple modal window (avoids deprecated
        # MessageDialog/response APIs)
        win = Gtk.Window(transient_for=self.window)
        win.set_title("Stop AnonSurf")
        win.set_modal(True)
        win.set_default_size(400, 160)

        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        vbox.set_margin_top(12)
        vbox.set_margin_bottom(12)
        vbox.set_margin_start(12)
        vbox.set_margin_end(12)

        label = Gtk.Label(label="You are about to stop anonymous browsing.\n\nActive browsers will be closed and cache files deleted.\n\nDo you wish to continue?")
        label.set_wrap(True)
        vbox.append(label)

        btn_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        btn_box.set_halign(Gtk.Align.END)

        no_btn = Gtk.Button.new_with_label("No")
        yes_btn = Gtk.Button.new_with_label("Yes")

        def on_yes(_):
            win.destroy()
            # Disable stop button temporarily and execute command
            self.stop_button.set_sensitive(False)
            self.run_anonsurf_command("stop", "Stopping anonymous browsing mode...")

        def on_no(_):
            win.destroy()

        yes_btn.connect("clicked", on_yes)
        no_btn.connect("clicked", on_no)

        btn_box.append(no_btn)
        btn_box.append(yes_btn)
        vbox.append(btn_box)

        win.set_child(vbox)
        win.present()

    # (Note) start/stop confirmation dialogs now use custom modal windows
    # instead of the deprecated response-based MessageDialog APIs.
    

    # Handle change IP button click
    def on_change_clicked(self, button):
        self.run_anonsurf_command("change", "Changing Tor nodes...")
    

    # Handle IP Details button click
    def on_info_clicked(self, button):
        def get_ip_info():
            try:
                # Build command with sudo as needed
                if self.password:
                    cmd = ['sudo', '-S', '/etc/init.d/anonsurf', 'ipinfo']
                    try:
                        try:
                            result = subprocess.run(cmd, input=self.password + '\n', capture_output=True, text=True, check=True, timeout=10.0)
                        except subprocess.TimeoutExpired:
                            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                    except subprocess.CalledProcessError:
                        raise
                elif self.can_sudo_nopass:
                    cmd = ['sudo', '-n', '/etc/init.d/anonsurf', 'ipinfo']
                    try:
                        try:
                            result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=10.0)
                        except subprocess.TimeoutExpired:
                            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                    except subprocess.CalledProcessError:
                        raise
                else:
                    # As a last resort try without sudo (may fail)
                    cmd = ['/etc/init.d/anonsurf', 'ipinfo']
                    try:
                        try:
                            result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=10.0)
                        except subprocess.TimeoutExpired:
                            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                    except subprocess.CalledProcessError:
                        raise
                
                # Parse XML output with proper XML parser
                try:
                    # Try to parse as XML first
                    xml_content = result.stdout.strip()
                    
                    # Clean up the XML by removing non-XML lines
                    lines = xml_content.split('\n')
                    xml_lines = []
                    in_xml = False
                    
                    for line in lines:
                        if line.strip().startswith('<') and not in_xml:
                            in_xml = True
                        if in_xml:
                            xml_lines.append(line)
                        if line.strip().endswith('>') and '/' in line:
                            break
                    
                    xml_data = '\n'.join(xml_lines)
                    
                    if xml_data.strip():
                        # Parse with ElementTree for better performance and reliability
                        root = ET.fromstring(xml_data)
                        parsed_info = []
                        
                        # Extract all text content from XML elements
                        for elem in root.iter():
                            if elem.text and elem.text.strip():
                                tag_name = elem.tag.replace('_', ' ').title()
                                parsed_info.append(f"{tag_name}: {elem.text.strip()}")
                        
                        info_text = '\n'.join(parsed_info) if parsed_info else "No IP information available"
                    else:
                        # Fallback to plain text output
                        info_text = result.stdout.strip() or "No IP information available"
                        
                except (ET.ParseError, Exception):
                    # Fallback to simple text processing if XML parsing fails
                    lines = result.stdout.split('\n')
                    parsed_info = []
                    
                    for line in lines:
                        line = line.strip()
                        if line and not line.startswith('<?') and not line.startswith('<!'):
                            # Simple tag extraction
                            if '<' in line and '>' in line:
                                try:
                                    start = line.find('>') + 1
                                    end = line.rfind('<')
                                    if start > 0 and end > start:
                                        content = line[start:end].strip()
                                        if content:
                                            tag = line[line.find('<')+1:line.find('>')]
                                            parsed_info.append(f"{tag}: {content}")
                                except:
                                    pass
                            else:
                                parsed_info.append(line)
                    
                    info_text = '\n'.join(parsed_info) if parsed_info else "No IP information available"
                GLib.idle_add(self.show_info_dialog, info_text)
                
            except subprocess.CalledProcessError as e:
                error_msg = f"Error getting IP info: {e}"
                GLib.idle_add(self.show_error, error_msg)
        
        #thread = threading.Thread(target=get_ip_info)
        #thread.daemon = True
        #thread.start()

        # NOTE: previously this started the fetch immediately; instead we now
        # show a brief informational dialog with an OK button and start the
        # fetch only after the user acknowledges. This prevents surprising
        # background work and informs the user of the expected wait time.
        def start_after_ack():
            # Show a dialog informing the user about potential delay
            info_win, vbox = self._create_dialog_window("IP Address Details", (420, 140))
            label = Gtk.Label(label="\nThis operation may take up to 15 seconds. Please be patient while the information is retrieved.\n\nClick OK to proceed.")
            label.set_wrap(True)
            vbox.append(label)

            ok_btn = Gtk.Button.new_with_label("OK")
            ok_btn.set_halign(Gtk.Align.CENTER)

            def on_ok(_):
                info_win.destroy()
                # Start the IP fetch in background
                #t = threading.Thread(target=get_ip_info)
                #t.daemon = True
                #t.start()
                get_ip_info()

            ok_btn.connect("clicked", on_ok)
            vbox.append(ok_btn)
            info_win.present()

        # Show the prefetch dialog
        start_after_ack()
    

    # Show IP information dialog
    def show_info_dialog(self, info_text: str):
        info_win = Adw.ApplicationWindow()
        info_win.set_title("Public IP Address Details")
        info_win.set_default_size(400, 350)
        info_win.set_transient_for(self.window)
        info_win.set_modal(True)
        
        # Content layout with clamp and vertical box
        clamp = Adw.Clamp()
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        vbox.set_margin_start(10)
        vbox.set_margin_end(10)
        vbox.set_margin_top(10)
        vbox.set_margin_bottom(10)
        clamp.set_child(vbox)
        
        scrolled = Gtk.ScrolledWindow()
        scrolled.set_hexpand(True)
        scrolled.set_vexpand(True)
        text_view = Gtk.TextView()
        text_view.set_editable(False)
        text_view.set_wrap_mode(Gtk.WrapMode.WORD_CHAR)
        buffer = text_view.get_buffer()
        buffer.set_text(info_text)
        scrolled.set_child(text_view)
        vbox.append(scrolled)
        
        # Actions row
        actions = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        actions.set_halign(Gtk.Align.END)
        
        copy_btn = Gtk.Button.new_with_label("Copy")
        copy_btn.set_tooltip_text("Copy to clipboard")
        def on_copy(_btn):
            display = info_win.get_display()
            clipboard = display.get_clipboard()
            data = info_text.encode('utf-8')
            bytes_obj = GLib.Bytes.new(data)
            provider = Gdk.ContentProvider.new_for_bytes('text/plain;charset=utf-8', bytes_obj)
            clipboard.set(provider)
        copy_btn.connect("clicked", on_copy)
        actions.append(copy_btn)
        
        save_btn = Gtk.Button.new_with_label("Save")
        save_btn.set_tooltip_text("Save to file…")

        def on_save(_btn):
            file_dialog = Gtk.FileDialog()
            file_dialog.set_initial_name("ip-info.txt")
            def on_save_complete(fdlg, res):
                try:
                    gfile = fdlg.save_finish(res)
                    if gfile is not None:
                        path = gfile.get_path() if hasattr(gfile, 'get_path') else None
                        if path:
                            try:
                                with open(path, 'w', encoding='utf-8') as f:
                                    f.write(info_text)
                                self.show_notification(f"Saved to {path}")
                            except Exception as e:
                                self.show_error(f"Failed to write file: {e}")
                except Exception as e:
                    self.show_error(f"Save cancelled or failed: {e}")
            file_dialog.save(info_win, None, on_save_complete)
        
        save_btn.connect("clicked", on_save)
        actions.append(save_btn)
        
        close_btn = Gtk.Button.new_with_label("Close")
        close_btn.set_tooltip_text("Close")
        close_btn.connect("clicked", lambda _b: info_win.destroy())
        actions.append(close_btn)
        
        vbox.append(actions)
        
        info_win.set_content(clamp)
        info_win.present()
    

    # Run AnonSurf command with progress dialog
    def run_anonsurf_command(self, action: str, progress_text: str):
        def run_command():
            try:
                # Build command with sudo as needed
                if self.password:
                    cmd = ['sudo', '-S', '/etc/init.d/anonsurf', action]
                    try:
                        try:
                            subprocess.run(cmd, input=self.password + '\n', capture_output=True, text=True, check=True, timeout=30.0)
                        except subprocess.TimeoutExpired:
                            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                    except subprocess.CalledProcessError:
                        raise
                elif self.can_sudo_nopass:
                    cmd = ['sudo', '-n', '/etc/init.d/anonsurf', action]
                    try:
                        try:
                            subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=30.0)
                        except subprocess.TimeoutExpired:
                            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                    except subprocess.CalledProcessError:
                        raise
                else:
                    cmd = ['/etc/init.d/anonsurf', action]
                    try:
                        try:
                            subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=30.0)
                        except subprocess.TimeoutExpired:
                            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                    except subprocess.CalledProcessError:
                        raise
                
                # Update status after command completes
                GLib.idle_add(self.update_status)
                GLib.idle_add(self.show_notification, f"AnonSurf {action} completed successfully")
                
            except subprocess.CalledProcessError as e:
                error_msg = f"Error running AnonSurf {action}: {e}"
                GLib.idle_add(self.show_error, error_msg)
        
        # Show progress dialog
        progress_win = Adw.ApplicationWindow()
        progress_win.set_title("AnonSurf")
        progress_win.set_default_size(350, 150)
        progress_win.set_transient_for(self.window)
        progress_win.set_modal(True)
        
        # Content layout with clamp and vertical box
        clamp = Adw.Clamp()
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=16)
        vbox.set_margin_start(20)
        vbox.set_margin_end(20)
        vbox.set_margin_top(20)
        vbox.set_margin_bottom(20)
        clamp.set_child(vbox)
        
        # Progress label
        label = Gtk.Label(label=progress_text)
        label.set_halign(Gtk.Align.CENTER)
        vbox.append(label)
        
        # Progress bar
        progress_bar = Gtk.ProgressBar()
        progress_bar.set_fraction(0.0)
        progress_bar.set_hexpand(True)
        vbox.append(progress_bar)
        
        progress_win.set_content(clamp)
        progress_win.present()
        
        # Animate progress bar
        def animate_progress():
            current = progress_bar.get_fraction()
            if current < 0.9:
                progress_bar.set_fraction(current + 0.1)
                return True
            return False
        
        GLib.timeout_add(100, animate_progress)
        
        # Run command in background
        thread = threading.Thread(target=run_command)
        thread.daemon = True
        thread.start()
        
        # Close progress dialog after a delay
        GLib.timeout_add(2000, progress_win.destroy)
    

    # Show error dialog
    def show_error(self, message: str):
        error_win, vbox = self._create_dialog_window("Error", (400, 200))
        
        # Error icon and message
        error_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=12)
        error_icon = Gtk.Image.new_from_icon_name("dialog-error-symbolic")
        error_icon.set_pixel_size(48)
        error_box.append(error_icon)
        
        error_label = Gtk.Label(label=message)
        error_label.set_wrap(True)
        error_label.set_hexpand(True)
        error_box.append(error_label)
        
        vbox.append(error_box)
        
        # Close button
        close_btn = Gtk.Button.new_with_label("Close")
        close_btn.set_halign(Gtk.Align.CENTER)
        close_btn.connect("clicked", lambda _b: error_win.destroy())
        vbox.append(close_btn)
        
        error_win.present()

    # Show notification (simplified version)
    def show_notification(self, message: str):
        notif_win, vbox = self._create_dialog_window("AnonSurf", (400, 150))
        
        # Success icon and message
        success_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=12)
        success_icon = Gtk.Image.new_from_icon_name("anonsurf")
        success_icon.set_pixel_size(48)
        success_box.append(success_icon)
        
        success_label = Gtk.Label(label=message)
        success_label.set_wrap(True)
        success_label.set_hexpand(True)
        success_box.append(success_label)
        
        vbox.append(success_box)
        
        # Close button
        close_btn = Gtk.Button.new_with_label("Close")
        close_btn.set_halign(Gtk.Align.CENTER)
        close_btn.connect("clicked", lambda _b: notif_win.destroy())
        vbox.append(close_btn)
        
        notif_win.present()

    # Show About dialog
    def on_about_clicked(self, button):
        # Close the popover menu
        if hasattr(self, 'about_popover'):
            self.about_popover.popdown()
        
        about_win = Adw.ApplicationWindow()
        about_win.set_title("About AnonSurf")
        about_win.set_default_size(400, 300)
        about_win.set_transient_for(self.window)
        about_win.set_modal(True)
        
        # Content layout with clamp and vertical box
        clamp = Adw.Clamp()
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=16)
        vbox.set_margin_start(20)
        vbox.set_margin_end(20)
        vbox.set_margin_top(20)
        vbox.set_margin_bottom(20)
        clamp.set_child(vbox)
        
        # App icon and title
        icon_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        icon_box.set_halign(Gtk.Align.CENTER)
        
        app_icon = Gtk.Image.new_from_icon_name("anonsurf")
        app_icon.set_pixel_size(64)
        icon_box.append(app_icon)
        
        app_title = Gtk.Label(label="AnonSurf")
        app_title.add_css_class("title-1")
        icon_box.append(app_title)
        
        vbox.append(icon_box)
        
        # Version
        version_label = Gtk.Label(label="Version 1.2.0")
        version_label.add_css_class("dim-label")
        version_label.set_halign(Gtk.Align.CENTER)
        vbox.append(version_label)
        
        # Description
        desc_label = Gtk.Label(label="Anonymous Browsing Service\nA more secure way to browse the internet.")
        desc_label.set_wrap(True)
        desc_label.set_halign(Gtk.Align.CENTER)
        desc_label.set_margin_top(16)
        vbox.append(desc_label)
        
        # Close button
        close_btn = Gtk.Button.new_with_label("Close")
        close_btn.set_halign(Gtk.Align.CENTER)
        close_btn.set_margin_top(16)
        close_btn.connect("clicked", lambda _b: about_win.destroy())
        vbox.append(close_btn)
        
        about_win.set_content(clamp)
        about_win.present()

    # Handle quit menu item
    def on_quit_clicked(self, button):
        # Close the popover menu
        if hasattr(self, 'about_popover'):
            self.about_popover.popdown()
        
        # Quit the application
        self.window.get_application().quit()



def main():
    # Create Adwaita application
    app = Adw.Application(application_id="org.anonsurf.gui")
    
    def on_activate(application):
        window = AnonSurfGUI()
        window.window.set_application(application)
        window.window.present()
    
    app.connect("activate", on_activate)
    app.run(None)



if __name__ == "__main__":
    main()
