#!/usr/bin/env python3

import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Gdk', '4.0')
gi.require_version('Adw', '1')
from gi.repository import Gtk, Gdk, GLib, GObject, Adw
import warnings
import subprocess
import os
import sys
import threading
import tempfile
import xml.etree.ElementTree as ET
from typing import Optional
import time
import signal


class AnonSurfGUI:
    def __init__(self):
        # Use Gtk.ApplicationWindow to allow setting a custom titlebar
        self.window = Gtk.ApplicationWindow()
        self.window.set_title("AnonSurf")
        self.window.set_name("anonsurf")  # Set internal name
        self.window.connect("close-request", self.on_window_close)
        
        # Performance optimizations
        self._status_cache = {}
        self._last_status_check = 0
        self._status_cache_timeout = 2.0  # Cache for 2 seconds
        self._subprocess_timeout = 10.0  # 10 second timeout for subprocess calls
        
        # Add CSS styling for regular font weight
        css_provider = Gtk.CssProvider()
        # Suppress upstream deprecation for CssProvider.load_from_data
        # (the gi override emits a DeprecationWarning). We keep using
        # load_from_data for compatibility but avoid noisy warnings.
        css = """
        .regular-weight {
            font-weight: normal;
        }
        .header-title {
            font-size: 14px;
            font-weight: 800;
        }
        .header-title-box {
            margin: 0;
            padding: 0;
        }
        .header-title-box label {
            margin: 0;
            padding: 0;
        }
        .tor-active {
            background-color: #e8f5e8;
            border: 2px solid #4caf50;
        }
        /* Ensure the main panel background reflects Tor status even when
           theme classes (e.g. light-mode) are present. Target both the
           window-level class as a parent and the panel itself. */
        .tor-active .main-panel,
        .main-panel.tor-active {
            background-color: #e8f5e8;
        }
        .tor-active headerbar {
            background-color: #4caf50;
            color: white;
        }
        .tor-inactive {
            background-color: #ffebee;
            border: 2px solid #f44336;
        }
        .tor-inactive .main-panel,
        .main-panel.tor-inactive {
            background-color: #ffebee;
        }
        .tor-inactive headerbar {
            background-color: #f44336;
            color: white;
        }
        /* Main panel background for light and dark modes. The clamp is
           transparent by default so the window-level background can show
           through; explicit light/dark rules are applied via classes on
           the window to ensure consistent theming across Adw widgets. */
        .main-panel {
            background-color: transparent;
        }

        .light-mode .main-panel {
            background-color: #ffffff;
            color: #111111;
        }

        .main-panel.light-mode {
            background-color: #ffffff;
            color: #111111;
        }

        /* When a Tor status class is present, make it more specific
           than the generic light-mode rule so the status background
           wins in light themes. */
        .light-mode .main-panel.tor-active,
        .main-panel.light-mode.tor-active {
            background-color: #e8f5e8;
            color: #111111;
        }

        .light-mode .main-panel.tor-inactive,
        .main-panel.light-mode.tor-inactive {
            background-color: #ffebee;
            color: #111111;
        }

        .main-panel.dark-mode {
            background-color: #2b2b2b;
            color: #eeeeee;
        }

        /* Remove any panel border/shadow in dark mode so the window
           retains the visual border while the inner panel appears
           seamless with the background. */
        .dark-mode .main-panel,
        .main-panel.dark-mode,
        .dark-mode .main-panel.tor-active,
        .main-panel.dark-mode.tor-active,
        .dark-mode .main-panel.tor-inactive,
        .main-panel.dark-mode.tor-inactive {
            border: none;
            box-shadow: none;
        }

        .dark-mode {
            background-color: #2b2b2b;
            color: #eeeeee;
        }

        .dark-mode headerbar {
            background-color: #1f1f1f;
            color: #ffffff;
        }
        """
        with warnings.catch_warnings():
            warnings.filterwarnings(
                "ignore",
                message=".*CssProvider.load_from_data.*",
                category=DeprecationWarning,
            )
            css_provider.load_from_data(css.encode())
        Gtk.StyleContext.add_provider_for_display(
            Gdk.Display.get_default(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        # Keep the window in sync with the system color scheme.
        try:
            style_manager = Adw.StyleManager.get_default()

            def _on_scheme_change(sm, prop=None):
                try:
                    is_dark = sm.get_color_scheme() == Adw.ColorScheme.DARK
                except Exception:
                    # Be conservative: assume light if we can't determine
                    is_dark = False

                # Also respect Gtk preference which some environments set
                try:
                    settings = Gtk.Settings.get_default()
                    if settings and settings.get_property('gtk-application-prefer-dark-theme'):
                        is_dark = True
                except Exception:
                    pass

                if is_dark:
                    self.window.add_css_class('dark-mode')
                    self.window.remove_css_class('light-mode')
                    try:
                        GLib.idle_add(self.window.set_title, "AnonSurf")
                    except Exception:
                        pass
                else:
                    self.window.add_css_class('light-mode')
                    self.window.remove_css_class('dark-mode')
                    try:
                        GLib.idle_add(self.window.set_title, "AnonSurf")
                    except Exception:
                        pass

                # Mirror onto the main clamp if it exists so background
                # styling is applied directly to the panel widget.
                try:
                    clamp_exists = hasattr(self, 'main_clamp') and self.main_clamp is not None
                    gtk_pref = None
                    try:
                        s = Gtk.Settings.get_default()
                        if s:
                            gtk_pref = s.get_property('gtk-application-prefer-dark-theme')
                    except Exception:
                        pass
                    if clamp_exists:
                        if is_dark:
                            self.main_clamp.add_css_class('dark-mode')
                            self.main_clamp.remove_css_class('light-mode')
                        else:
                            self.main_clamp.add_css_class('light-mode')
                            self.main_clamp.remove_css_class('dark-mode')
                except Exception:
                    pass
                # Record for later if the UI hasn't created the clamp yet
                try:
                    self._pending_scheme_is_dark = is_dark
                except Exception:
                    pass

            # Apply initial scheme
            # Start with an explicit light-mode class; the handler will
            # switch to dark-mode if needed.
            self.window.add_css_class('light-mode')
            # Ensure we have a pending scheme flag in case the UI isn't
            # created yet (we'll apply to the clamp once it's available).
            self._pending_scheme_is_dark = None
            _on_scheme_change(style_manager)

            # React to changes at runtime
            style_manager.connect('notify::color-scheme', _on_scheme_change)

            # Also react to Gtk preference changes as some environments set
            # the dark preference via Gtk.Settings instead of Adw.StyleManager
            try:
                settings = Gtk.Settings.get_default()
                if settings:
                    def _on_gtk_pref_change(settings_obj, prop):
                        _on_scheme_change(style_manager)

                    settings.connect('notify::gtk-application-prefer-dark-theme', _on_gtk_pref_change)
            except Exception:
                pass
        except Exception:
            # If Adw.StyleManager isn't available or lacks methods on older
            # versions, silently continue with default styling.
            pass
        
        # Add a Gtk.HeaderBar with title and subtitle
        headerbar = Gtk.HeaderBar()
        headerbar.set_show_title_buttons(True)
        
        # Create title box with proper vertical centering
        title_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
        title_box.set_halign(Gtk.Align.CENTER)
        title_box.set_valign(Gtk.Align.CENTER)
        title_box.add_css_class("header-title-box")
        
        title_label = Gtk.Label(label="AnonSurf")
        title_label.add_css_class("header-title")
        title_label.set_halign(Gtk.Align.CENTER)
        title_label.set_valign(Gtk.Align.CENTER)
        
        subtitle_label = Gtk.Label(label="Anonymous Browsing Service")
        subtitle_label.add_css_class("dim-label")
        subtitle_label.set_halign(Gtk.Align.CENTER)
        subtitle_label.set_valign(Gtk.Align.CENTER)
        
        title_box.append(title_label)
        title_box.append(subtitle_label)
        headerbar.set_title_widget(title_box)
        
        # Add menu button with dropdown
        menu_button = Gtk.MenuButton()
        menu_button.set_icon_name("open-menu-symbolic")
        menu_button.set_tooltip_text("Menu")
        
        # Create popover menu (use Gtk.Popover to host custom content)
        popover = Gtk.Popover()
        menu_button.set_popover(popover)
        
        # Store popover reference for closing
        self.about_popover = popover
        
        # Create menu box
        menu_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        popover.set_child(menu_box)
        
        # Add About menu item
        about_item = Gtk.Button()
        about_item.set_label("About AnonSurf")
        about_item.connect("clicked", self.on_about_clicked)
        about_item.add_css_class("flat")
        about_item.add_css_class("regular-weight")
        about_item.set_halign(Gtk.Align.FILL)
        about_item.set_hexpand(True)
        # Get the child label and set it to left-align
        about_label = about_item.get_child()
        if about_label:
            about_label.set_halign(Gtk.Align.START)
        menu_box.append(about_item)
        
        # Add Quit menu item
        quit_item = Gtk.Button()
        quit_item.set_label("Quit")
        quit_item.connect("clicked", self.on_quit_clicked)
        quit_item.add_css_class("flat")
        quit_item.add_css_class("regular-weight")
        quit_item.set_halign(Gtk.Align.FILL)
        quit_item.set_hexpand(True)
        # Get the child label and set it to left-align
        quit_label = quit_item.get_child()
        if quit_label:
            quit_label.set_halign(Gtk.Align.START)
        menu_box.append(quit_item)
        
        headerbar.pack_end(menu_button)
        
        self.window.set_titlebar(headerbar)
        
        # Store password for sudo operations
        self.password: Optional[str] = None
        # Track if passwordless sudo is available
        self.can_sudo_nopass: bool = False
        
        # Check dependencies and initialize
        if not self.check_dependencies():
            sys.exit(1)
        
        if not self.init_sudo():
            sys.exit(1)
        
        self.setup_ui()
        self.update_status()
    
    # Handle window close request
    def on_window_close(self, window):
        Gtk.Application.get_default().quit()
        return False
    
    # Check if required dependencies are installed
    def check_dependencies(self) -> bool:
        # Check if AnonSurf CLI is installed
        if not os.path.exists('/etc/init.d/anonsurf'):
            self.show_error("Error: AnonSurf CLI is not installed.")
            return False
        
        # Check if curl is available
        try:
            subprocess.run(['curl', '--version'], capture_output=True, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            self.show_error("Error: Curl is not installed.")
            return False
        
        return True
    
    # Helper for creating consistent dialog windows
    def _create_dialog_window(self, title, default_size=(400, 200), modal=True):
        # Create a standardized dialog window with consistent styling
        dialog = Adw.ApplicationWindow()
        dialog.set_title(title)
        dialog.set_default_size(*default_size)
        dialog.set_transient_for(self.window)
        dialog.set_modal(modal)
        
        # Create consistent layout structure
        clamp = Adw.Clamp()
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=16)
        vbox.set_margin_start(20)
        vbox.set_margin_end(20)
        vbox.set_margin_top(20)
        vbox.set_margin_bottom(20)
        clamp.set_child(vbox)
        dialog.set_content(clamp)
        
        return dialog, vbox
    
    # Helper for Libadwaita confirmation dialogs
    def _show_confirmation_dialog(self, title: str, body: str, on_accept):
        dialog = Adw.MessageDialog.new(self.window, title, body)

        dialog.add_response("cancel", "No")
        dialog.add_response("accept", "Yes")
        dialog.set_default_response("accept")
        dialog.set_close_response("cancel")
        dialog.set_response_appearance("accept", Adw.ResponseAppearance.SUGGESTED)

        def _on_response(dlg, response):
            if response == "accept":
                try:
                    on_accept()
                except Exception:
                    pass
            dlg.destroy()

        dialog.connect("response", _on_response)
        dialog.present()
    
    # Initialize sudo access
    def init_sudo(self) -> bool:
        if os.geteuid() != 0:
            # Try sudo without password first
            try:
                subprocess.run(['sudo', '-n', 'true'], check=True)
                self.can_sudo_nopass = True
                return True
            except FileNotFoundError:
                # `sudo` is not available on this system
                self.show_error("Error: 'sudo' is not installed. Please install sudo or run as root.")
                return False
            except subprocess.CalledProcessError:
                # Need password: use a Libadwaita message dialog with a password field
                dialog = Adw.MessageDialog.new(
                    self.window,
                    "Permission Required",
                    "Enter your password to run AnonSurf with administrative privileges."
                )

                entry = Gtk.PasswordEntry()
                entry.set_placeholder_text("Password")
                dialog.set_extra_child(entry)

                dialog.add_response("cancel", "Cancel")
                dialog.add_response("ok", "OK")
                dialog.set_default_response("ok")
                dialog.set_close_response("cancel")
                dialog.set_response_appearance("ok", Adw.ResponseAppearance.SUGGESTED)

                self.sudo_response = None

                def _on_response(dlg, response):
                    if response == "ok":
                        self.sudo_response = entry.get_text()
                    else:
                        self.sudo_response = ""
                    dlg.destroy()

                dialog.connect("response", _on_response)
                dialog.present()

                # Wait for response using a simple loop (not ideal but works)
                self.sudo_response = None
                while self.sudo_response is None:
                    GLib.MainContext.default().iteration(True)

                password = self.sudo_response
                
                if password:
                    self.password = password
                    # Test the password
                    try:
                        # Provide the password as a string and include a newline
                        # so sudo receives a full line via stdin.
                        subprocess.run(['sudo', '-S', 'true'], input=password + '\n', capture_output=True, check=True, text=True)
                        return True
                    except FileNotFoundError:
                        self.show_error("Error: 'sudo' is not installed. Please install sudo or run as root.")
                        return False
                    except subprocess.CalledProcessError:
                        self.show_error("Error: Invalid password.")
                        return False
                else:
                    self.show_error("Error: No password entered. Aborting.")
                    return False
        else:
            # Running as root; no sudo needed
            self.can_sudo_nopass = True
        return True
    


    # Initialize the main UI
    def setup_ui(self):
        
        # Main container wrapped in Adw.Clamp for responsive margins
        clamp = Adw.Clamp()
        clamp.add_css_class('main-panel')
        # Keep a reference so theme handlers can mirror classes onto the clamp
        # after it is created.
        self.main_clamp = clamp

        # If theme handler ran earlier, apply the pending scheme to the clamp
        try:
            pending = getattr(self, '_pending_scheme_is_dark', None)
            if pending is True:
                clamp.add_css_class('dark-mode')
                clamp.remove_css_class('light-mode')
            elif pending is False:
                clamp.add_css_class('light-mode')
                clamp.remove_css_class('dark-mode')
        except Exception:
            pass
        
        #main_vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        main_vbox = Gtk.Box()
        clamp.set_child(main_vbox)
        
        # (Reverted) Remove large Quick Actions buttons; use Adwaita action rows below
        
        # Status section (Adwaita native)
        prefs_page = Adw.PreferencesPage()
        prefs_page.set_title("AnonSurf") # Set a title for the preferences page
        
        # Status group
        #status_group = Adw.PreferencesGroup(title="Status")
        status_group = Adw.PreferencesGroup()
        status_group.set_margin_start(10)
        status_group.set_margin_end(10)
        
        # Tor status row
        self.tor_row = Adw.ActionRow(title="Tor Service", subtitle="Unknown")
        status_group.add(self.tor_row)
        
        # IP address row with refresh suffix button
        self.ip_row = Adw.ActionRow(title="Public IP Address", subtitle="Unknown")
        status_group.add(self.ip_row)
        
        prefs_page.add(status_group)
        
        # Toggle button section (separate from other actions)
        toggle_group = Adw.PreferencesGroup()
        
        # Button container for start/stop
        start_stop_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        start_stop_box.set_margin_start(10)
        start_stop_box.set_margin_end(10)
        start_stop_box.set_margin_top(10)
        start_stop_box.set_margin_bottom(10)
        
        # Start button
        self.start_button = Gtk.Button()
        self.start_button.set_tooltip_text("Start Tor service")
        self.start_button.connect("clicked", self.on_start_clicked)
        self.start_button.set_hexpand(True)
        self.start_button.set_size_request(-1, 120)  # Fixed height of 120px
        
        # Start button icon and label
        start_vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=4)
        start_vbox.set_halign(Gtk.Align.CENTER)
        start_vbox.set_valign(Gtk.Align.CENTER)
        start_icon = Gtk.Image.new_from_icon_name("media-playback-start-symbolic")
        start_icon.set_pixel_size(32)
        start_label = Gtk.Label(label="Start")
        start_vbox.append(start_icon)
        start_vbox.append(start_label)
        self.start_button.set_child(start_vbox)
        start_stop_box.append(self.start_button)
        
        # Stop button
        self.stop_button = Gtk.Button()
        self.stop_button.set_tooltip_text("Stop Tor service")
        self.stop_button.connect("clicked", self.on_stop_clicked)
        self.stop_button.set_hexpand(True)
        self.stop_button.set_size_request(-1, 120)  # Fixed height of 120px
        
        # Stop button icon and label
        stop_vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=4)
        stop_vbox.set_halign(Gtk.Align.CENTER)
        stop_vbox.set_valign(Gtk.Align.CENTER)
        stop_icon = Gtk.Image.new_from_icon_name("media-playback-stop-symbolic")
        stop_icon.set_pixel_size(32)
        stop_label = Gtk.Label(label="Stop")
        stop_vbox.append(stop_icon)
        stop_vbox.append(stop_label)
        self.stop_button.set_child(stop_vbox)
        start_stop_box.append(self.stop_button)
        
        toggle_group.add(start_stop_box)
        prefs_page.add(toggle_group)
        
        # Actions section with traditional buttons
        actions_group = Adw.PreferencesGroup()
        
        # Button container for other actions
        button_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        button_box.set_margin_start(10)
        button_box.set_margin_end(10)
        button_box.set_margin_top(0)
        button_box.set_margin_bottom(0)
        
        # Change IP button
        self.change_btn = Gtk.Button(label="Change IP Address")
        self.change_btn.set_tooltip_text("Reload Tor circuits to obtain a new exit node")
        self.change_btn.connect("clicked", self.on_change_clicked)
        button_box.append(self.change_btn)
        
        # Show IP details button
        info_btn = Gtk.Button(label="IP Address Details")
        info_btn.set_tooltip_text("Show geolocation and ISP details")
        info_btn.connect("clicked", self.on_info_clicked)
        button_box.append(info_btn)
        
        actions_group.add(button_box)
        prefs_page.add(actions_group)
        
        main_vbox.append(prefs_page)
        
        # Install into window
        self.window.set_child(clamp)
        
        # Set application icon
        try:
            self.window.set_icon_name("anonsurf")
        except Exception as e:
            print(f"Warning: Could not set application icon: {e}")
        
        self.window.set_default_size(400, 470)
        self.window.set_resizable(False)
    

    # Update the status display with caching to reduce system calls
    def update_status(self, force_refresh=False):
        current_time = time.time()
        
        # Check cache first (unless force refresh)
        if not force_refresh and (current_time - self._last_status_check) < self._status_cache_timeout:
            if 'tor_status' in self._status_cache and 'ip_address' in self._status_cache:
                self.update_status_labels(
                    self._status_cache['tor_status'], 
                    self._status_cache['ip_address']
                )
                return
        
        def update():
            try:
                # Get Tor status with timeout
                try:
                    cmd = ['systemctl', 'is-active', 'tor']
                    try:
                        result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=5.0)
                    except subprocess.TimeoutExpired:
                        # Keep behavior consistent with previous helper
                        raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                    tor_status = result.stdout.strip()
                except subprocess.CalledProcessError:
                    tor_status = "inactive"

                # Get IP address with timeout (only if Tor is active to reduce unnecessary calls)
                if tor_status == "active":
                    try:
                        cmd = ['curl', '-s', '--max-time', '8', 'icanhazip.com']
                        try:
                            result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=10.0)
                        except subprocess.TimeoutExpired:
                            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                        ip_address = result.stdout.strip()
                        # Validate IP format
                        if not ip_address or len(ip_address.split('.')) != 4:
                            ip_address = "Unknown"
                    except subprocess.CalledProcessError:
                        ip_address = "Unknown"
                else:
                    # Don't waste time checking IP if Tor is inactive
                    ip_address = "Not connected"

                # Cache results
                self._status_cache = {
                    'tor_status': tor_status,
                    'ip_address': ip_address
                }
                self._last_status_check = time.time()

                # Update UI in main thread
                GLib.idle_add(self.update_status_labels, tor_status, ip_address)
                
            except Exception as e:
                # Fallback on any error
                GLib.idle_add(self.update_status_labels, "Error", f"Error: {str(e)}")

        # Run in background thread
        thread = threading.Thread(target=update)
        thread.daemon = True
        thread.start()
    

    # Update status labels (called from main thread)
    def update_status_labels(self, tor_status: str, ip_address: str):
        self.tor_row.set_subtitle(tor_status)
        self.ip_row.set_subtitle(ip_address)
        
        # Apply window color based on Tor status
        # Remove existing status classes first
        self.window.remove_css_class("tor-active")
        self.window.remove_css_class("tor-inactive")
        
        # Add appropriate status class (window-level)
        if tor_status == "active":
            self.window.add_css_class("tor-active")
        else:
            self.window.add_css_class("tor-inactive")

        try:
            if hasattr(self, 'main_clamp') and self.main_clamp is not None:
                self.main_clamp.remove_css_class('tor-active')
                self.main_clamp.remove_css_class('tor-inactive')
                if tor_status == "active":
                    self.main_clamp.add_css_class('tor-active')
                else:
                    self.main_clamp.add_css_class('tor-inactive')
        except Exception:
            pass
        
        # Sync button states with Tor status
        if hasattr(self, 'start_button') and hasattr(self, 'stop_button'):
            is_active = tor_status == "active"
            self.start_button.set_sensitive(not is_active)  # Enable start when inactive
            self.stop_button.set_sensitive(is_active)       # Enable stop when active
            
            # Also sync the Change IP button - only enable when Tor is running
            if hasattr(self, 'change_btn'):
                self.change_btn.set_sensitive(is_active)

    # Handle start button click
    def on_start_clicked(self, button):
        body = (
            "You are about to start the anonymous browsing service.\n\n"
            "Active browsers will be closed and cache files deleted.\n\n"
            "Do you wish to continue?"
        )

        def do_start():
            # Disable start button temporarily and execute command
            self.start_button.set_sensitive(False)
            self.run_anonsurf_command("start", "Starting anonymous browsing mode...")

        self._show_confirmation_dialog("Start AnonSurf", body, do_start)
    
    # Handle stop button click
    def on_stop_clicked(self, button):
        body = (
            "You are about to stop anonymous browsing.\n\n"
            "Active browsers will be closed and cache files deleted.\n\n"
            "Do you wish to continue?"
        )

        def do_stop():
            # Disable stop button temporarily and execute command
            self.stop_button.set_sensitive(False)
            self.run_anonsurf_command("stop", "Stopping anonymous browsing mode...")

        self._show_confirmation_dialog("Stop AnonSurf", body, do_stop)
    

    # Handle change IP button click
    def on_change_clicked(self, button):
        self.run_anonsurf_command("change", "Changing Tor nodes...")
    

    # Handle IP Details button click
    def on_info_clicked(self, button):
        def get_ip_info():
            try:
                # Build command with sudo as needed
                if self.password:
                    cmd = ['sudo', '-S', '/etc/init.d/anonsurf', 'ipinfo']
                    try:
                        try:
                            result = subprocess.run(cmd, input=self.password + '\n', capture_output=True, text=True, check=True, timeout=10.0)
                        except subprocess.TimeoutExpired:
                            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                    except subprocess.CalledProcessError:
                        raise
                elif self.can_sudo_nopass:
                    cmd = ['sudo', '-n', '/etc/init.d/anonsurf', 'ipinfo']
                    try:
                        try:
                            result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=10.0)
                        except subprocess.TimeoutExpired:
                            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                    except subprocess.CalledProcessError:
                        raise
                else:
                    # As a last resort try without sudo (may fail)
                    cmd = ['/etc/init.d/anonsurf', 'ipinfo']
                    try:
                        try:
                            result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=10.0)
                        except subprocess.TimeoutExpired:
                            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                    except subprocess.CalledProcessError:
                        raise
                
                # Parse XML output with proper XML parser
                try:
                    # Try to parse as XML first
                    xml_content = result.stdout.strip()
                    
                    # Clean up the XML by removing non-XML lines
                    lines = xml_content.split('\n')
                    xml_lines = []
                    in_xml = False
                    
                    for line in lines:
                        if line.strip().startswith('<') and not in_xml:
                            in_xml = True
                        if in_xml:
                            xml_lines.append(line)
                        if line.strip().endswith('>') and '/' in line:
                            break
                    
                    xml_data = '\n'.join(xml_lines)
                    
                    if xml_data.strip():
                        # Parse with ElementTree for better performance and reliability
                        root = ET.fromstring(xml_data)
                        parsed_info = []
                        
                        # Extract all text content from XML elements
                        for elem in root.iter():
                            if elem.text and elem.text.strip():
                                tag_name = elem.tag.replace('_', ' ').title()
                                parsed_info.append(f"{tag_name}: {elem.text.strip()}")
                        
                        info_text = '\n'.join(parsed_info) if parsed_info else "No IP information available"
                    else:
                        # Fallback to plain text output
                        info_text = result.stdout.strip() or "No IP information available"
                        
                except (ET.ParseError, Exception):
                    # Fallback to simple text processing if XML parsing fails
                    lines = result.stdout.split('\n')
                    parsed_info = []
                    
                    for line in lines:
                        line = line.strip()
                        if line and not line.startswith('<?') and not line.startswith('<!'):
                            # Simple tag extraction
                            if '<' in line and '>' in line:
                                try:
                                    start = line.find('>') + 1
                                    end = line.rfind('<')
                                    if start > 0 and end > start:
                                        content = line[start:end].strip()
                                        if content:
                                            tag = line[line.find('<')+1:line.find('>')]
                                            parsed_info.append(f"{tag}: {content}")
                                except:
                                    pass
                            else:
                                parsed_info.append(line)
                    
                    info_text = '\n'.join(parsed_info) if parsed_info else "No IP information available"
                GLib.idle_add(self.show_info_dialog, info_text)
                
            except subprocess.CalledProcessError as e:
                error_msg = f"Error getting IP info: {e}"
                GLib.idle_add(self.show_error, error_msg)
        
        #thread = threading.Thread(target=get_ip_info)
        #thread.daemon = True
        #thread.start()

        # NOTE: previously this started the fetch immediately; instead we now
        # show a brief informational dialog and start the fetch after user
        # acknowledgement, using Libadwaita dialogs.
        def start_after_ack():
            # Libadwaita dialog informing about potential delay
            body = (
                "This operation may take up to 15 seconds.\n\n"
                "Please be patient while the information is retrieved."
            )
            dialog = Adw.MessageDialog.new(
                self.window,
                "IP Address Details",
                body,
            )

            dialog.add_response("cancel", "Cancel")
            dialog.add_response("ok", "OK")
            dialog.set_default_response("ok")
            dialog.set_close_response("cancel")
            dialog.set_response_appearance("ok", Adw.ResponseAppearance.SUGGESTED)

            def _on_response(dlg, response):
                if response == "ok":
                    # Start the IP fetch (runs synchronously as before)
                    get_ip_info()
                dlg.destroy()

            dialog.connect("response", _on_response)
            dialog.present()

        # Show the prefetch dialog
        start_after_ack()
    

    # Show IP information dialog (Libadwaita message dialog with extra content)
    def show_info_dialog(self, info_text: str):
        dialog = Adw.MessageDialog.new(
            self.window,
            "Public IP Address Details",
            None,
        )

        # Use a scrolled, read-only text view as extra child
        scrolled = Gtk.ScrolledWindow()
        scrolled.set_hexpand(True)
        scrolled.set_vexpand(True)
        scrolled.set_min_content_height(200)
        scrolled.set_min_content_width(400)

        text_view = Gtk.TextView()
        text_view.set_editable(False)
        text_view.set_wrap_mode(Gtk.WrapMode.WORD_CHAR)
        buffer = text_view.get_buffer()
        buffer.set_text(info_text)

        scrolled.set_child(text_view)
        dialog.set_extra_child(scrolled)

        # Responses: Copy, Save, Close
        dialog.add_response("copy", "Copy")
        dialog.add_response("save", "Save")
        dialog.add_response("close", "Close")
        dialog.set_default_response("close")
        dialog.set_close_response("close")
        dialog.set_response_appearance("close", Adw.ResponseAppearance.SUGGESTED)

        def _on_response(dlg, response):
            if response == "copy":
                display = self.window.get_display()
                clipboard = display.get_clipboard()
                data = info_text.encode('utf-8')
                bytes_obj = GLib.Bytes.new(data)
                provider = Gdk.ContentProvider.new_for_bytes(
                    'text/plain;charset=utf-8',
                    bytes_obj,
                )
                clipboard.set(provider)

            elif response == "save":
                file_dialog = Gtk.FileDialog()
                file_dialog.set_initial_name("ip-info.txt")

                def on_save_complete(fdlg, res):
                    try:
                        gfile = fdlg.save_finish(res)
                        if gfile is not None:
                            path = gfile.get_path() if hasattr(gfile, 'get_path') else None
                            if path:
                                try:
                                    with open(path, 'w', encoding='utf-8') as f:
                                        f.write(info_text)
                                    self.show_notification(f"Saved to {path}")
                                except Exception as e:
                                    self.show_error(f"Failed to write file: {e}")
                    except Exception as e:
                        self.show_error(f"Save cancelled or failed: {e}")

                file_dialog.save(self.window, None, on_save_complete)

            # Always destroy at the end
            dlg.destroy()

        dialog.connect("response", _on_response)
        dialog.present()
    
    
    # Run AnonSurf command with Libadwaita progress dialog
    def run_anonsurf_command(self, action: str, progress_text: str):
        # Create a Libadwaita message dialog to show progress
        dialog = Adw.MessageDialog.new(
            self.window,
            "AnonSurf",
            None,
        )

        # No explicit responses; close programmatically when done
        # Use an extra child containing label + progress bar
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=16)
        vbox.set_margin_start(20)
        vbox.set_margin_end(20)
        vbox.set_margin_top(20)
        vbox.set_margin_bottom(20)

        label = Gtk.Label(label=progress_text)
        label.set_wrap(True)
        label.set_halign(Gtk.Align.CENTER)
        vbox.append(label)

        progress_bar = Gtk.ProgressBar()
        progress_bar.set_fraction(0.0)
        progress_bar.set_hexpand(True)
        vbox.append(progress_bar)

        dialog.set_extra_child(vbox)
        dialog.present()

        # Animate progress bar while command is running
        def animate_progress():
            current = progress_bar.get_fraction()
            if current < 0.9:
                progress_bar.set_fraction(current + 0.05)
                return True
            return False

        GLib.timeout_add(100, animate_progress)

        def run_command():
            try:
                # Build command with sudo as needed
                if self.password:
                    cmd = ['sudo', '-S', '/etc/init.d/anonsurf', action]
                    try:
                        try:
                            subprocess.run(
                                cmd,
                                input=self.password + '\n',
                                capture_output=True,
                                text=True,
                                check=True,
                                timeout=30.0,
                            )
                        except subprocess.TimeoutExpired:
                            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                    except subprocess.CalledProcessError:
                        raise
                elif self.can_sudo_nopass:
                    cmd = ['sudo', '-n', '/etc/init.d/anonsurf', action]
                    try:
                        try:
                            subprocess.run(
                                cmd,
                                capture_output=True,
                                text=True,
                                check=True,
                                timeout=30.0,
                            )
                        except subprocess.TimeoutExpired:
                            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                    except subprocess.CalledProcessError:
                        raise
                else:
                    cmd = ['/etc/init.d/anonsurf', action]
                    try:
                        try:
                            subprocess.run(
                                cmd,
                                capture_output=True,
                                text=True,
                                check=True,
                                timeout=30.0,
                            )
                        except subprocess.TimeoutExpired:
                            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
                    except subprocess.CalledProcessError:
                        raise

                # Update status and notify on success
                GLib.idle_add(self.update_status)
                GLib.idle_add(self.show_notification, f"AnonSurf {action} completed successfully")

            except subprocess.CalledProcessError as e:
                error_msg = f"Error running AnonSurf {action}: {e}"
                GLib.idle_add(self.show_error, error_msg)
            finally:
                # Ensure dialog is closed on the main thread
                GLib.idle_add(dialog.destroy)

        # Run command in background
        thread = threading.Thread(target=run_command)
        thread.daemon = True
        thread.start()
    
    
    # Show error dialog
    def show_error(self, message: str):
        dialog = Adw.MessageDialog.new(
            self.window,
            "Error",
            message,
        )

        dialog.add_response("close", "Close")
        dialog.set_default_response("close")
        dialog.set_close_response("close")
        dialog.set_response_appearance("close", Adw.ResponseAppearance.DESTRUCTIVE)

        dialog.connect("response", lambda dlg, _r: dlg.destroy())
        dialog.present()
    
    # Show notification (Libadwaita message dialog)
    def show_notification(self, message: str):
        dialog = Adw.MessageDialog.new(
            self.window,
            "AnonSurf",
            message,
        )

        dialog.add_response("ok", "OK")
        dialog.set_default_response("ok")
        dialog.set_close_response("ok")
        dialog.set_response_appearance("ok", Adw.ResponseAppearance.SUGGESTED)

        dialog.connect("response", lambda dlg, _r: dlg.destroy())
        dialog.present()
    
    # Show About dialog
    def on_about_clicked(self, button):
        # Close the popover menu
        if hasattr(self, 'about_popover'):
            self.about_popover.popdown()

        # Use a Libadwaita AboutWindow with the current API
        about = Adw.AboutWindow()
        about.set_transient_for(self.window)
        about.set_modal(True)

        # Use properties instead of deprecated setters
        about.props.application_name = "AnonSurf"
        about.props.application_icon = "anonsurf"
        about.props.version = "1.2.0"
        about.props.developer_name = "Roy Prins"
        about.props.website = "https://github.com/rajprins/anonsurf"
        about.props.issue_url = "https://github.com/rajprins/anonsurf/issues"
        about.props.comments = "Anonymous Browsing Service â€” a more secure way to browse the internet."

        # Set license - try Gtk.License enum first, fallback to string
        try:
            if hasattr(Gtk, 'License') and hasattr(Gtk.License, 'GPL_3_0'):
                about.props.license_type = Gtk.License.GPL_3_0
            else:
                # Fallback: set license text directly
                about.props.license = "GPL-3.0"
        except (AttributeError, TypeError):
            # If license properties don't work, just skip it
            pass

        about.present()

    # Handle quit menu item
    def on_quit_clicked(self, button):
        # Close the popover menu
        if hasattr(self, 'about_popover'):
            self.about_popover.popdown()
        
        # Quit the application
        self.window.get_application().quit()



def main():
    # Create Adwaita application
    app = Adw.Application(application_id="org.anonsurf.gui")
    
    def on_activate(application):
        window = AnonSurfGUI()
        window.window.set_application(application)
        window.window.present()
    
    app.connect("activate", on_activate)
    app.run(None)



if __name__ == "__main__":
    main()
