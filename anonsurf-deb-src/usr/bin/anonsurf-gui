#!/usr/bin/env python3

import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Gdk', '4.0')
gi.require_version('Adw', '1')
from gi.repository import Gtk, Gdk, GLib, GObject, Adw
import subprocess
import os
import sys
import threading
import tempfile
import xml.etree.ElementTree as ET
from typing import Optional
import time
import signal

# Try to set process name for better identification
try:
    import setproctitle
    setproctitle.setproctitle("anonsurf")
except ImportError:
    # Fallback: try to set argv[0] (works on most systems)
    if len(sys.argv) > 0:
        sys.argv[0] = "anonsurf"
    # Alternative: try to set process title via ctypes (Linux only)
    try:
        import ctypes
        libc = ctypes.CDLL("libc.so.6")
        libc.prctl(15, b"anonsurf", 0, 0, 0)  # PR_SET_NAME = 15
    except (ImportError, OSError, AttributeError):
        pass  # Silently fail if not supported

class AnonSurfGUI:
    def __init__(self):
        # Use Gtk.ApplicationWindow to allow setting a custom titlebar
        self.window = Gtk.ApplicationWindow()
        self.window.set_title("AnonSurf")
        self.window.set_name("anonsurf")  # Set internal name
        self.window.connect("close-request", self.on_window_close)
        
        # Performance optimizations
        self._status_cache = {}
        self._last_status_check = 0
        self._status_cache_timeout = 2.0  # Cache for 2 seconds
        self._subprocess_timeout = 10.0  # 10 second timeout for subprocess calls
        
        # Add CSS styling for regular font weight
        css_provider = Gtk.CssProvider()
        css_provider.load_from_data("""
        .regular-weight {
            font-weight: normal;
        }
        .header-title {
            font-size: 14px;
            font-weight: 800;
        }
        .header-title-box {
            margin: 0;
            padding: 0;
        }
        .header-title-box label {
            margin: 0;
            padding: 0;
        }
        .tor-active {
            background-color: #e8f5e8;
            border: 2px solid #4caf50;
        }
        .tor-inactive {
            background-color: #ffebee;
            border: 2px solid #f44336;
        }
        """.encode())
        Gtk.StyleContext.add_provider_for_display(
            Gdk.Display.get_default(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )
        
        # Add a Gtk.HeaderBar with title and subtitle
        headerbar = Gtk.HeaderBar()
        headerbar.set_show_title_buttons(True)
        
        # Create title box with proper vertical centering
        title_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=2)
        title_box.set_halign(Gtk.Align.CENTER)
        title_box.set_valign(Gtk.Align.CENTER)
        title_box.add_css_class("header-title-box")
        
        title_label = Gtk.Label(label="AnonSurf")
        title_label.add_css_class("header-title")
        title_label.set_halign(Gtk.Align.CENTER)
        title_label.set_valign(Gtk.Align.CENTER)
        
        subtitle_label = Gtk.Label(label="Anonymous Browsing Service")
        subtitle_label.add_css_class("dim-label")
        subtitle_label.set_halign(Gtk.Align.CENTER)
        subtitle_label.set_valign(Gtk.Align.CENTER)
        
        title_box.append(title_label)
        title_box.append(subtitle_label)
        headerbar.set_title_widget(title_box)
        
        # Add menu button with dropdown
        menu_button = Gtk.MenuButton()
        menu_button.set_icon_name("open-menu-symbolic")
        menu_button.set_tooltip_text("Menu")
        
        # Create popover menu (use Gtk.Popover to host custom content)
        popover = Gtk.Popover()
        menu_button.set_popover(popover)
        
        # Store popover reference for closing
        self.about_popover = popover
        
        # Create menu box
        menu_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        popover.set_child(menu_box)
        
        # Add About menu item
        about_item = Gtk.Button()
        about_item.set_label("About AnonSurf")
        about_item.connect("clicked", self.on_about_clicked)
        about_item.add_css_class("flat")
        about_item.add_css_class("regular-weight")
        about_item.set_halign(Gtk.Align.FILL)
        about_item.set_hexpand(True)
        # Get the child label and set it to left-align
        about_label = about_item.get_child()
        if about_label:
            about_label.set_halign(Gtk.Align.START)
        menu_box.append(about_item)
        
        # Add Quit menu item
        quit_item = Gtk.Button()
        quit_item.set_label("Quit")
        quit_item.connect("clicked", self.on_quit_clicked)
        quit_item.add_css_class("flat")
        quit_item.add_css_class("regular-weight")
        quit_item.set_halign(Gtk.Align.FILL)
        quit_item.set_hexpand(True)
        # Get the child label and set it to left-align
        quit_label = quit_item.get_child()
        if quit_label:
            quit_label.set_halign(Gtk.Align.START)
        menu_box.append(quit_item)
        
        headerbar.pack_end(menu_button)
        
        self.window.set_titlebar(headerbar)
        
        # Store password for sudo operations
        self.password: Optional[str] = None
        # Track if passwordless sudo is available
        self.can_sudo_nopass: bool = False
        
        # Check dependencies and initialize
        if not self.check_dependencies():
            sys.exit(1)
        
        if not self.init_sudo():
            sys.exit(1)
        
        self.setup_ui()
        self.update_status()
    
    # Handle window close request
    def on_window_close(self, window):
        Gtk.Application.get_default().quit()
        return False
    
    # Check if required dependencies are installed
    def check_dependencies(self) -> bool:
        # Check if AnonSurf CLI is installed
        if not os.path.exists('/etc/init.d/anonsurf'):
            self.show_error("Error: AnonSurf CLI is not installed.")
            return False
        
        # Check if curl is available
        try:
            subprocess.run(['curl', '--version'], capture_output=True, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            self.show_error("Error: Curl is not installed.")
            return False
        
        return True
    
    # Safe subprocess execution with timeout
    def _run_subprocess_safe(self, cmd, input_data=None, timeout=None):
        """Run subprocess with timeout and proper error handling"""
        if timeout is None:
            timeout = self._subprocess_timeout
        
        try:
            result = subprocess.run(
                cmd,
                input=input_data,
                    capture_output=True,
                    text=True,
                check=True,
                timeout=timeout
            )
            return result
        except subprocess.TimeoutExpired:
            raise subprocess.CalledProcessError(1, cmd, "Command timed out")
        except subprocess.CalledProcessError as e:
            raise e
    
    # Helper for creating consistent dialog windows
    def _create_dialog_window(self, title, default_size=(400, 200), modal=True):
        """Create a standardized dialog window with consistent styling"""
        dialog = Adw.ApplicationWindow()
        dialog.set_title(title)
        dialog.set_default_size(*default_size)
        dialog.set_transient_for(self.window)
        dialog.set_modal(modal)
        
        # Create consistent layout structure
        clamp = Adw.Clamp()
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=16)
        vbox.set_margin_start(20)
        vbox.set_margin_end(20)
        vbox.set_margin_top(20)
        vbox.set_margin_bottom(20)
        clamp.set_child(vbox)
        dialog.set_content(clamp)
        
        return dialog, vbox
    
    # Initialize sudo access
    def init_sudo(self) -> bool:
        if os.geteuid() != 0:
            # Try sudo without password first
            try:
                subprocess.run(['sudo', '-n', 'true'], check=True)
                self.can_sudo_nopass = True
                return True
            except subprocess.CalledProcessError:
                # Need password
                dialog = Gtk.Dialog()
                dialog.set_title("Sudo Password")
                dialog.set_transient_for(self.window)
                dialog.set_modal(True)
                dialog.set_default_size(300, 100)
                
                content_area = dialog.get_content_area()
                
                label = Gtk.Label(label="Enter sudo password:")
                entry = Gtk.PasswordEntry()
                entry.set_activates_default(True)
                
                content_area.append(label)
                content_area.append(entry)
                
                dialog.add_button("Cancel", Gtk.ResponseType.CANCEL)
                dialog.add_button("OK", Gtk.ResponseType.OK)
                dialog.set_default_response(Gtk.ResponseType.OK)
                
                # Store entry reference for response handler
                dialog.entry = entry
                dialog.connect("response", self.on_sudo_response)
                dialog.present()
                
                # Wait for response using a simple loop (not ideal but works)
                self.sudo_response = None
                while self.sudo_response is None:
                    GLib.MainContext.default().iteration(True)
                
                password = self.sudo_response
                dialog.destroy()
                
                if password:
                    self.password = password
                    # Test the password
                    try:
                        subprocess.run(['sudo', '-S', 'true'], input=password.encode(), capture_output=True, check=True)
                        return True
                    except subprocess.CalledProcessError:
                        self.show_error("Error: Invalid password.")
                        return False
                else:
                    self.show_error("Error: No password entered. Aborting.")
                    return False
        else:
            # Running as root; no sudo needed
            self.can_sudo_nopass = True
        return True
    

    # Handle sudo password dialog response"
    def on_sudo_response(self, dialog, response):
        if response == Gtk.ResponseType.OK:
            self.sudo_response = dialog.entry.get_text()
        else:
            self.sudo_response = ""
        
        return True
    

    # Initialize the main UI
    def setup_ui(self):
        
        # Main container wrapped in Adw.Clamp for responsive margins
        clamp = Adw.Clamp()
        
        #main_vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        main_vbox = Gtk.Box()
        clamp.set_child(main_vbox)
        
        # (Reverted) Remove large Quick Actions buttons; use Adwaita action rows below
        
        # Status section (Adwaita native)
        prefs_page = Adw.PreferencesPage()
        prefs_page.set_title("AnonSurf") # Set a title for the preferences page
        
        # Status group
        #status_group = Adw.PreferencesGroup(title="Status")
        status_group = Adw.PreferencesGroup()
        status_group.set_margin_start(10)
        status_group.set_margin_end(10)
        
        # Tor status row
        self.tor_row = Adw.ActionRow(title="Tor Service", subtitle="Unknown")
        status_group.add(self.tor_row)
        
        # IP address row with refresh suffix button
        self.ip_row = Adw.ActionRow(title="IP Address", subtitle="Unknown")
        refresh_button = Gtk.Button.new_from_icon_name("view-refresh-symbolic")
        refresh_button.set_tooltip_text("Refresh status")
        refresh_button.connect("clicked", self.on_refresh_clicked)
        self.ip_row.add_suffix(refresh_button)
        self.ip_row.set_activatable_widget(refresh_button)
        status_group.add(self.ip_row)
        
        prefs_page.add(status_group)
        
        # Toggle button section (separate from other actions)
        #toggle_group = Adw.PreferencesGroup(title="Service Control")
        toggle_group = Adw.PreferencesGroup()
        
        # Button container for start/stop
        start_stop_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        start_stop_box.set_margin_start(10)
        start_stop_box.set_margin_end(10)
        start_stop_box.set_margin_top(10)
        start_stop_box.set_margin_bottom(10)
        
        # Start button
        self.start_button = Gtk.Button()
        self.start_button.set_tooltip_text("Start Tor service")
        self.start_button.connect("clicked", self.on_start_clicked)
        self.start_button.set_hexpand(True)
        self.start_button.set_size_request(-1, 120)  # Fixed height of 120px
        
        # Start button icon and label
        start_vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=4)
        start_vbox.set_halign(Gtk.Align.CENTER)
        start_vbox.set_valign(Gtk.Align.CENTER)
        start_icon = Gtk.Image.new_from_icon_name("media-playback-start-symbolic")
        start_icon.set_pixel_size(32)
        start_label = Gtk.Label(label="Start")
        start_vbox.append(start_icon)
        start_vbox.append(start_label)
        self.start_button.set_child(start_vbox)
        start_stop_box.append(self.start_button)
        
        # Stop button
        self.stop_button = Gtk.Button()
        self.stop_button.set_tooltip_text("Stop Tor service")
        self.stop_button.connect("clicked", self.on_stop_clicked)
        self.stop_button.set_hexpand(True)
        self.stop_button.set_size_request(-1, 120)  # Fixed height of 120px
        
        # Stop button icon and label
        stop_vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=4)
        stop_vbox.set_halign(Gtk.Align.CENTER)
        stop_vbox.set_valign(Gtk.Align.CENTER)
        stop_icon = Gtk.Image.new_from_icon_name("media-playback-stop-symbolic")
        stop_icon.set_pixel_size(32)
        stop_label = Gtk.Label(label="Stop")
        stop_vbox.append(stop_icon)
        stop_vbox.append(stop_label)
        self.stop_button.set_child(stop_vbox)
        start_stop_box.append(self.stop_button)
        
        toggle_group.add(start_stop_box)
        prefs_page.add(toggle_group)
        
        # Actions section with traditional buttons
        #actions_group = Adw.PreferencesGroup(title="Actions")
        actions_group = Adw.PreferencesGroup()
        
        # Button container for other actions
        button_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        button_box.set_margin_start(10)
        button_box.set_margin_end(10)
        button_box.set_margin_top(0)
        button_box.set_margin_bottom(0)
        
        # Change IP button
        self.change_btn = Gtk.Button(label="Change IP Address")
        self.change_btn.set_tooltip_text("Reload Tor circuits to obtain a new exit node")
        self.change_btn.connect("clicked", self.on_change_clicked)
        button_box.append(self.change_btn)
        
        # Show IP details button
        info_btn = Gtk.Button(label="IP Address Details")
        info_btn.set_tooltip_text("Show geolocation and ISP details")
        info_btn.connect("clicked", self.on_info_clicked)
        button_box.append(info_btn)
        
        actions_group.add(button_box)
        prefs_page.add(actions_group)
        
        main_vbox.append(prefs_page)
        
        # Install into window
        self.window.set_child(clamp)
        
        # Set application icon
        try:
            self.window.set_icon_name("anonsurf")
        except Exception as e:
            print(f"Warning: Could not set application icon: {e}")
        
        self.window.set_default_size(400, 470)
        self.window.set_resizable(False)
    

    # Update the status display
    def update_status(self, force_refresh=False):
        """Update status with caching to reduce system calls"""
        current_time = time.time()
        
        # Check cache first (unless force refresh)
        if not force_refresh and (current_time - self._last_status_check) < self._status_cache_timeout:
            if 'tor_status' in self._status_cache and 'ip_address' in self._status_cache:
                self.update_status_labels(
                    self._status_cache['tor_status'], 
                    self._status_cache['ip_address']
                )
                return
        
        def update():
            try:
                # Get Tor status with timeout
                try:
                    result = self._run_subprocess_safe(['systemctl', 'is-active', 'tor'], timeout=5.0)
                    tor_status = result.stdout.strip()
                except subprocess.CalledProcessError:
                    tor_status = "inactive"

                # Get IP address with timeout (only if Tor is active to reduce unnecessary calls)
                if tor_status == "active":
                    try:
                        result = self._run_subprocess_safe(['curl', '-s', '--max-time', '8', 'icanhazip.com'], timeout=10.0)
                        ip_address = result.stdout.strip()
                        # Validate IP format
                        if not ip_address or len(ip_address.split('.')) != 4:
                            ip_address = "Unknown"
                    except subprocess.CalledProcessError:
                        ip_address = "Unknown"
                else:
                    # Don't waste time checking IP if Tor is inactive
                    ip_address = "Not connected"

                # Cache results
                self._status_cache = {
                    'tor_status': tor_status,
                    'ip_address': ip_address
                }
                self._last_status_check = time.time()

                # Update UI in main thread
                GLib.idle_add(self.update_status_labels, tor_status, ip_address)
                
            except Exception as e:
                # Fallback on any error
                GLib.idle_add(self.update_status_labels, "Error", f"Error: {str(e)}")

        # Run in background thread
        thread = threading.Thread(target=update)
        thread.daemon = True
        thread.start()
    

    # Update status labels (called from main thread)
    def update_status_labels(self, tor_status: str, ip_address: str):
        self.tor_row.set_subtitle(tor_status)
        self.ip_row.set_subtitle(ip_address)
        
        # Apply window color based on Tor status
        # Remove existing status classes first
        self.window.remove_css_class("tor-active")
        self.window.remove_css_class("tor-inactive")
        
        # Add appropriate status class
        if tor_status == "active":
            self.window.add_css_class("tor-active")
        else:
            self.window.add_css_class("tor-inactive")
        
        # Sync button states with Tor status
        if hasattr(self, 'start_button') and hasattr(self, 'stop_button'):
            is_active = tor_status == "active"
            self.start_button.set_sensitive(not is_active)  # Enable start when inactive
            self.stop_button.set_sensitive(is_active)       # Enable stop when active
            
            # Also sync the Change IP button - only enable when Tor is running
            if hasattr(self, 'change_btn'):
                self.change_btn.set_sensitive(is_active)

    # Handle start button click
    def on_start_clicked(self, button):
        # Show confirmation dialog
        dialog = Gtk.MessageDialog(
            transient_for=self.window,
            message_type=Gtk.MessageType.QUESTION,
            buttons=Gtk.ButtonsType.YES_NO,
            text="Start AnonSurf",
            secondary_text="You are about to start the anonymous browsing service.\n\nActive browsers will be closed and cache files deleted.\n\nDo you wish to continue?"
        )
        
        dialog.connect("response", self.on_start_response)
        dialog.present()

    # Handle start dialog response
    def on_start_response(self, dialog, response):
        dialog.destroy()
        if response == Gtk.ResponseType.YES:
            # Disable start button temporarily
            self.start_button.set_sensitive(False)
            self.run_anonsurf_command("start", "Starting anonymous browsing mode...")

    # Handle stop button click
    def on_stop_clicked(self, button):
        # Show confirmation dialog
        dialog = Gtk.MessageDialog(
            transient_for=self.window,
            message_type=Gtk.MessageType.QUESTION,
            buttons=Gtk.ButtonsType.YES_NO,
            text="Stop AnonSurf",
            secondary_text="You are about to stop anonymous browsing.\n\nActive browsers will be closed and cache files deleted.\n\nDo you wish to continue?"
        )
        
        dialog.connect("response", self.on_stop_response)
        dialog.present()

    # Handle stop dialog response
    def on_stop_response(self, dialog, response):
        dialog.destroy()
        if response == Gtk.ResponseType.YES:
            # Disable stop button temporarily
            self.stop_button.set_sensitive(False)
            self.run_anonsurf_command("stop", "Stopping anonymous browsing mode...")
    

    # Handle refresh button click
    def on_refresh_clicked(self, button):
        # Force refresh bypasses cache
        self.update_status(force_refresh=True)

    # Handle change IP button click
    def on_change_clicked(self, button):
        self.run_anonsurf_command("change", "Changing Tor nodes...")
    

    # Handle info button click"
    def on_info_clicked(self, button):
        def get_ip_info():
            try:
                # Build command with sudo as needed
                if self.password:
                    cmd = ['sudo', '-S', '/etc/init.d/anonsurf', 'ipinfo']
                    result = self._run_subprocess_safe(cmd, input_data=self.password.encode(), timeout=15.0)
                elif self.can_sudo_nopass:
                    cmd = ['sudo', '-n', '/etc/init.d/anonsurf', 'ipinfo']
                    result = self._run_subprocess_safe(cmd, timeout=15.0)
                else:
                    # As a last resort try without sudo (may fail)
                    cmd = ['/etc/init.d/anonsurf', 'ipinfo']
                    result = self._run_subprocess_safe(cmd, timeout=15.0)
                
                # Parse XML output with proper XML parser
                try:
                    # Try to parse as XML first
                    xml_content = result.stdout.strip()
                    
                    # Clean up the XML by removing non-XML lines
                    lines = xml_content.split('\n')
                    xml_lines = []
                    in_xml = False
                    
                    for line in lines:
                        if line.strip().startswith('<') and not in_xml:
                            in_xml = True
                        if in_xml:
                            xml_lines.append(line)
                        if line.strip().endswith('>') and '/' in line:
                            break
                    
                    xml_data = '\n'.join(xml_lines)
                    
                    if xml_data.strip():
                        # Parse with ElementTree for better performance and reliability
                        root = ET.fromstring(xml_data)
                        parsed_info = []
                        
                        # Extract all text content from XML elements
                        for elem in root.iter():
                            if elem.text and elem.text.strip():
                                tag_name = elem.tag.replace('_', ' ').title()
                                parsed_info.append(f"{tag_name}: {elem.text.strip()}")
                        
                        info_text = '\n'.join(parsed_info) if parsed_info else "No IP information available"
                    else:
                        # Fallback to plain text output
                        info_text = result.stdout.strip() or "No IP information available"
                        
                except (ET.ParseError, Exception):
                    # Fallback to simple text processing if XML parsing fails
                    lines = result.stdout.split('\n')
                    parsed_info = []
                    
                    for line in lines:
                        line = line.strip()
                        if line and not line.startswith('<?') and not line.startswith('<!'):
                            # Simple tag extraction
                            if '<' in line and '>' in line:
                                try:
                                    start = line.find('>') + 1
                                    end = line.rfind('<')
                                    if start > 0 and end > start:
                                        content = line[start:end].strip()
                                        if content:
                                            tag = line[line.find('<')+1:line.find('>')]
                                            parsed_info.append(f"{tag}: {content}")
                                except:
                                    pass
                            else:
                                parsed_info.append(line)
                    
                    info_text = '\n'.join(parsed_info) if parsed_info else "No IP information available"
                GLib.idle_add(self.show_info_dialog, info_text)
                
            except subprocess.CalledProcessError as e:
                error_msg = f"Error getting IP info: {e}"
                GLib.idle_add(self.show_error, error_msg)
        
        thread = threading.Thread(target=get_ip_info)
        thread.daemon = True
        thread.start()
    

    # Show IP information dialog
    def show_info_dialog(self, info_text: str):
        """Show IP information in an Adwaita-styled window"""
        info_win = Adw.ApplicationWindow()
        info_win.set_title("Public IP Address Details")
        info_win.set_default_size(400, 350)
        info_win.set_transient_for(self.window)
        info_win.set_modal(True)
        
        # Content layout with clamp and vertical box
        clamp = Adw.Clamp()
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        vbox.set_margin_start(10)
        vbox.set_margin_end(10)
        vbox.set_margin_top(10)
        vbox.set_margin_bottom(10)
        clamp.set_child(vbox)
        
        scrolled = Gtk.ScrolledWindow()
        scrolled.set_hexpand(True)
        scrolled.set_vexpand(True)
        text_view = Gtk.TextView()
        text_view.set_editable(False)
        text_view.set_wrap_mode(Gtk.WrapMode.WORD_CHAR)
        buffer = text_view.get_buffer()
        buffer.set_text(info_text)
        scrolled.set_child(text_view)
        vbox.append(scrolled)
        
        # Actions row
        actions = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        actions.set_halign(Gtk.Align.END)
        
        copy_btn = Gtk.Button.new_with_label("Copy")
        copy_btn.set_tooltip_text("Copy to clipboard")
        def on_copy(_btn):
            display = info_win.get_display()
            clipboard = display.get_clipboard()
            data = info_text.encode('utf-8')
            bytes_obj = GLib.Bytes.new(data)
            provider = Gdk.ContentProvider.new_for_bytes('text/plain;charset=utf-8', bytes_obj)
            clipboard.set(provider)
        copy_btn.connect("clicked", on_copy)
        actions.append(copy_btn)
        
        save_btn = Gtk.Button.new_with_label("Save")
        save_btn.set_tooltip_text("Save to fileâ€¦")

        def on_save(_btn):
            file_dialog = Gtk.FileDialog()
            file_dialog.set_initial_name("ip-info.txt")
            def on_save_complete(fdlg, res):
                try:
                    gfile = fdlg.save_finish(res)
                    if gfile is not None:
                        path = gfile.get_path() if hasattr(gfile, 'get_path') else None
                        if path:
                            try:
                                with open(path, 'w', encoding='utf-8') as f:
                                    f.write(info_text)
                                self.show_notification(f"Saved to {path}")
                            except Exception as e:
                                self.show_error(f"Failed to write file: {e}")
                except Exception as e:
                    self.show_error(f"Save cancelled or failed: {e}")
            file_dialog.save(info_win, None, on_save_complete)
        
        save_btn.connect("clicked", on_save)
        actions.append(save_btn)
        
        close_btn = Gtk.Button.new_with_label("Close")
        close_btn.set_tooltip_text("Close")
        close_btn.connect("clicked", lambda _b: info_win.destroy())
        actions.append(close_btn)
        
        vbox.append(actions)
        
        info_win.set_content(clamp)
        info_win.present()
    

    # Run AnonSurf command with progress dialog
    def run_anonsurf_command(self, action: str, progress_text: str):
        def run_command():
            try:
                # Build command with sudo as needed
                if self.password:
                    cmd = ['sudo', '-S', '/etc/init.d/anonsurf', action]
                    self._run_subprocess_safe(cmd, input_data=self.password.encode(), timeout=30.0)
                elif self.can_sudo_nopass:
                    cmd = ['sudo', '-n', '/etc/init.d/anonsurf', action]
                    self._run_subprocess_safe(cmd, timeout=30.0)
                else:
                    cmd = ['/etc/init.d/anonsurf', action]
                    self._run_subprocess_safe(cmd, timeout=30.0)
                
                # Update status after command completes
                GLib.idle_add(self.update_status)
                GLib.idle_add(self.show_notification, f"AnonSurf {action} completed successfully")
                
            except subprocess.CalledProcessError as e:
                error_msg = f"Error running AnonSurf {action}: {e}"
                GLib.idle_add(self.show_error, error_msg)
        
        # Show progress dialog
        progress_win = Adw.ApplicationWindow()
        progress_win.set_title("AnonSurf")
        progress_win.set_default_size(350, 150)
        progress_win.set_transient_for(self.window)
        progress_win.set_modal(True)
        
        # Content layout with clamp and vertical box
        clamp = Adw.Clamp()
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=16)
        vbox.set_margin_start(20)
        vbox.set_margin_end(20)
        vbox.set_margin_top(20)
        vbox.set_margin_bottom(20)
        clamp.set_child(vbox)
        
        # Progress label
        label = Gtk.Label(label=progress_text)
        label.set_halign(Gtk.Align.CENTER)
        vbox.append(label)
        
        # Progress bar
        progress_bar = Gtk.ProgressBar()
        progress_bar.set_fraction(0.0)
        progress_bar.set_hexpand(True)
        vbox.append(progress_bar)
        
        progress_win.set_content(clamp)
        progress_win.present()
        
        # Animate progress bar
        def animate_progress():
            current = progress_bar.get_fraction()
            if current < 0.9:
                progress_bar.set_fraction(current + 0.1)
                return True
            return False
        
        GLib.timeout_add(100, animate_progress)
        
        # Run command in background
        thread = threading.Thread(target=run_command)
        thread.daemon = True
        thread.start()
        
        # Close progress dialog after a delay
        GLib.timeout_add(2000, progress_win.destroy)
    

    # Show error dialog
    def show_error(self, message: str):
        error_win, vbox = self._create_dialog_window("Error", (400, 200))
        
        # Error icon and message
        error_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=12)
        error_icon = Gtk.Image.new_from_icon_name("dialog-error-symbolic")
        error_icon.set_pixel_size(48)
        error_box.append(error_icon)
        
        error_label = Gtk.Label(label=message)
        error_label.set_wrap(True)
        error_label.set_hexpand(True)
        error_box.append(error_label)
        
        vbox.append(error_box)
        
        # Close button
        close_btn = Gtk.Button.new_with_label("Close")
        close_btn.set_halign(Gtk.Align.CENTER)
        close_btn.connect("clicked", lambda _b: error_win.destroy())
        vbox.append(close_btn)
        
        error_win.present()

    # Show notification (simplified version)
    def show_notification(self, message: str):
        """Show notification (fallback dialog for environments without ToastOverlay)"""
        notif_win, vbox = self._create_dialog_window("AnonSurf", (400, 150))
        
        # Success icon and message
        success_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=12)
        success_icon = Gtk.Image.new_from_icon_name("anonsurf")
        success_icon.set_pixel_size(48)
        success_box.append(success_icon)
        
        success_label = Gtk.Label(label=message)
        success_label.set_wrap(True)
        success_label.set_hexpand(True)
        success_box.append(success_label)
        
        vbox.append(success_box)
        
        # Close button
        close_btn = Gtk.Button.new_with_label("Close")
        close_btn.set_halign(Gtk.Align.CENTER)
        close_btn.connect("clicked", lambda _b: notif_win.destroy())
        vbox.append(close_btn)
        
        notif_win.present()

    # Show About dialog
    def on_about_clicked(self, button):
        # Close the popover menu
        if hasattr(self, 'about_popover'):
            self.about_popover.popdown()
        
        about_win = Adw.ApplicationWindow()
        about_win.set_title("About AnonSurf")
        about_win.set_default_size(400, 300)
        about_win.set_transient_for(self.window)
        about_win.set_modal(True)
        
        # Content layout with clamp and vertical box
        clamp = Adw.Clamp()
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=16)
        vbox.set_margin_start(20)
        vbox.set_margin_end(20)
        vbox.set_margin_top(20)
        vbox.set_margin_bottom(20)
        clamp.set_child(vbox)
        
        # App icon and title
        icon_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        icon_box.set_halign(Gtk.Align.CENTER)
        
        app_icon = Gtk.Image.new_from_icon_name("anonsurf")
        app_icon.set_pixel_size(64)
        icon_box.append(app_icon)
        
        app_title = Gtk.Label(label="AnonSurf")
        app_title.add_css_class("title-1")
        icon_box.append(app_title)
        
        vbox.append(icon_box)
        
        # Version
        version_label = Gtk.Label(label="Version 1.1.0")
        version_label.add_css_class("dim-label")
        version_label.set_halign(Gtk.Align.CENTER)
        vbox.append(version_label)
        
        # Description
        desc_label = Gtk.Label(label="Anonymous browsing service")
        desc_label.set_wrap(True)
        desc_label.set_halign(Gtk.Align.CENTER)
        desc_label.set_margin_top(16)
        vbox.append(desc_label)
        
        # Close button
        close_btn = Gtk.Button.new_with_label("Close")
        close_btn.set_halign(Gtk.Align.CENTER)
        close_btn.set_margin_top(16)
        close_btn.connect("clicked", lambda _b: about_win.destroy())
        vbox.append(close_btn)
        
        about_win.set_content(clamp)
        about_win.present()

    # Handle quit menu item
    def on_quit_clicked(self, button):
        # Close the popover menu
        if hasattr(self, 'about_popover'):
            self.about_popover.popdown()
        
        # Quit the application
        self.window.get_application().quit()



def main():
    # Create Adwaita application
    app = Adw.Application(application_id="org.anonsurf.gui")
    
    def on_activate(application):
        window = AnonSurfGUI()
        window.window.set_application(application)
        window.window.present()
    
    app.connect("activate", on_activate)
    app.run(None)



if __name__ == "__main__":
    main()
